"use strict";(self.webpackChunkNacos=self.webpackChunkNacos||[]).push([[7272],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var a=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),u=c(n),p=o,h=u["".concat(l,".").concat(p)]||u[p]||m[p]||r;return n?a.createElement(h,i(i({ref:t},d),{},{components:n})):a.createElement(h,i({ref:t},d))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=p;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[u]="string"==typeof e?e:o,i[1]=s;for(var c=2;c<r;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},33343:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>m,frontMatter:()=>r,metadata:()=>s,toc:()=>c});var a=n(87462),o=(n(67294),n(3905));const r={title:"Nacos 1.3.0 new kernel construction process",keywords:["nacos1.3.0","kernel"],description:"Nacos 1.3.0 new kernel construction process"},i="Nacos 1.3.0 Documentation of features and functionality",s={permalink:"/en/blog/nacos-1.3.0-design",source:"@site/i18n/en/docusaurus-plugin-content-blog/nacos-1.3.0-design.md",title:"Nacos 1.3.0 new kernel construction process",description:"Nacos 1.3.0 new kernel construction process",date:"2023-10-10T11:47:41.000Z",formattedDate:"October 10, 2023",tags:[],readingTime:25.905,hasTruncateMarker:!1,authors:[],frontMatter:{title:"Nacos 1.3.0 new kernel construction process",keywords:["nacos1.3.0","kernel"],description:"Nacos 1.3.0 new kernel construction process"},prevItem:{title:"Nacos 1.2.0 \u6743\u9650\u63a7\u5236\u4ecb\u7ecd\u548c\u4f7f\u7528",permalink:"/en/blog/nacos 1.2.0 guide"},nextItem:{title:"Nacos \u4e24\u5468\u5e74\u732e\u793c\uff0cNacos 1.3.2 + Go SDK 1.0.0\u53d1\u5e03",permalink:"/en/blog/nacos-2nd-anniversary"}},l={authorsImageUrls:[]},c=[{value:"Summarize",id:"summarize",level:2},{value:"System parameters changes",id:"system-parameters-changes",level:2},{value:"Updates",id:"updates",level:3},{value:"The future overall logical architecture of Nacos and its components",id:"the-future-overall-logical-architecture-of-nacos-and-its-components",level:2},{value:"Nacos cluster member node addressing mode",id:"nacos-cluster-member-node-addressing-mode",level:2},{value:"Addressing mode details",id:"addressing-mode-details",level:3},{value:"FileConfigMemberLookup",id:"fileconfigmemberlookup",level:4},{value:"AddressServerMemberLookup",id:"addressservermemberlookup",level:4},{value:"How node management and addressing modes are combined",id:"how-node-management-and-addressing-modes-are-combined",level:3},{value:"Nacos consensus protocol protocol layer abstraction",id:"nacos-consensus-protocol-protocol-layer-abstraction",level:2},{value:"Consensus agreement abstraction",id:"consensus-agreement-abstraction",level:3},{value:"ConsistencyProtocol",id:"consistencyprotocol",level:4},{value:"Data operation request submission object\uff1aLog\u3001GetRequest",id:"data-operation-request-submission-objectloggetrequest",level:4},{value:"Function modules use consistency protocol\uff1aLogProcessor",id:"function-modules-use-consistency-protocollogprocessor",level:4},{value:"Summary",id:"summary",level:4},{value:"Consistent protocol layer workflow",id:"consistent-protocol-layer-workflow",level:3},{value:"The implementation option of CP protocol in Nacos consistency protocol layer\u2014\u2014JRaft",id:"the-implementation-option-of-cp-protocol-in-nacos-consistency-protocol-layerjraft",level:3},{value:"Q&amp;A: Why do you want to create multiple raft groups",id:"qa-why-do-you-want-to-create-multiple-raft-groups",level:4},{value:"JRaft operation and maintenance",id:"jraft-operation-and-maintenance",level:3},{value:"JRaft protocol related configuration parameters",id:"jraft-protocol-related-configuration-parameters",level:3},{value:"Linear reading parameter analysis",id:"linear-reading-parameter-analysis",level:4},{value:"Nacos embedded distributed ID",id:"nacos-embedded-distributed-id",level:2},{value:"Nacos embedded lightweight Derby-based distributed relational storage",id:"nacos-embedded-lightweight-derby-based-distributed-relational-storage",level:2},{value:"Background",id:"background",level:3},{value:"Design ideas",id:"design-ideas",level:3},{value:"aims",id:"aims",level:4},{value:"overall",id:"overall",level:4},{value:"Related data bearing objects",id:"related-data-bearing-objects",level:4},{value:"Configure publishing",id:"configure-publishing",level:4},{value:"How to use new features",id:"how-to-use-new-features",level:3},{value:"New features related operation and maintenance operations",id:"new-features-related-operation-and-maintenance-operations",level:3},{value:"insufficient",id:"insufficient",level:3},{value:"Future evolution",id:"future-evolution",level:3}],d={toc:c},u="wrapper";function m(e){let{components:t,...n}=e;return(0,o.kt)(u,(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("a",{name:"0YIG0"}),(0,o.kt)("h2",{id:"summarize"},"Summarize"),(0,o.kt)("p",null,"This 1.3.0 is implanted to a great extent, involving the modification of two large modules and the addition of a core module"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"nacos-core module modification",(0,o.kt)("ol",{parentName:"li"},(0,o.kt)("li",{parentName:"ol"},"nacos"),(0,o.kt)("li",{parentName:"ol"},"nacos internal event mechanism"),(0,o.kt)("li",{parentName:"ol"},"nacos consistency protocol layer"))),(0,o.kt)("li",{parentName:"ol"},"nacos-config module modification",(0,o.kt)("ol",{parentName:"li"},(0,o.kt)("li",{parentName:"ol"},"Add embedded distributed data storage components"),(0,o.kt)("li",{parentName:"ol"},"Separation of embedded storage and external storage"),(0,o.kt)("li",{parentName:"ol"},"Simple operation and maintenance of embedded storage"))),(0,o.kt)("li",{parentName:"ol"},"Add nacos-consistency module",(0,o.kt)("ol",{parentName:"li"},(0,o.kt)("li",{parentName:"ol"},"Unified abstraction for AP protocol and CP protocol")))),(0,o.kt)("a",{name:"rnkDY"}),(0,o.kt)("h2",{id:"system-parameters-changes"},"System parameters changes"),(0,o.kt)("a",{name:"1Gmg9"}),(0,o.kt)("h3",{id:"updates"},"Updates"),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:"center"},(0,o.kt)("strong",{parentName:"th"},"core")),(0,o.kt)("th",{parentName:"tr",align:null},"nacos.watch-file.max-dirs"),(0,o.kt)("th",{parentName:"tr",align:null},"JVM parameter"),(0,o.kt)("th",{parentName:"tr",align:null},"Maximum number of monitored directories"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:"center"}),(0,o.kt)("td",{parentName:"tr",align:null},"nacos.core.notify.ring-buffer-size"),(0,o.kt)("td",{parentName:"tr",align:null},"JVM parameter"),(0,o.kt)("td",{parentName:"tr",align:null},"Quick notification of the maximum length of the queue")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:"center"}),(0,o.kt)("td",{parentName:"tr",align:null},"nacos.core.notify.share-buffer-size"),(0,o.kt)("td",{parentName:"tr",align:null},"JVM parameter"),(0,o.kt)("td",{parentName:"tr",align:null},"The maximum length of the slow notification queue")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:"center"}),(0,o.kt)("td",{parentName:"tr",align:null},"nacos.core.member.fail-access-cnt"),(0,o.kt)("td",{parentName:"tr",align:null},"JVM parameter.properties"),(0,o.kt)("td",{parentName:"tr",align:null},"Maximum number of failed visits to cluster member nodes")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:"center"}),(0,o.kt)("td",{parentName:"tr",align:null},"nacos.core.address-server.retry"),(0,o.kt)("td",{parentName:"tr",align:null},"JVM parameter\u3001application.properties"),(0,o.kt)("td",{parentName:"tr",align:null},"Address server addressing mode, first start request retry times")))),(0,o.kt)("br",null),(0,o.kt)("a",{name:"kxo8O"}),(0,o.kt)("h2",{id:"the-future-overall-logical-architecture-of-nacos-and-its-components"},"The future overall logical architecture of Nacos and its components"),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://cdn.nlark.com/yuque/0/2020/png/333972/1587129046320-5a286f38-8db4-4e76-9b42-8bd859f51a60.png#align=left&display=inline&height=1184&margin=%5Bobject%20Object%5D&name=1561217775318-6e408805-18bb-4242-b4e9-83c5b929b469.png&originHeight=1184&originWidth=1608&size=279074&status=done&style=none&width=1608",alt:"1561217775318-6e408805-18bb-4242-b4e9-83c5b929b469.png"})),(0,o.kt)("a",{name:"Hyc6u"}),(0,o.kt)("h2",{id:"nacos-cluster-member-node-addressing-mode"},"Nacos cluster member node addressing mode"),(0,o.kt)("p",null,"Before 1.3.0, nacos' naming module and config module had their own member list management tasks. In order to unify the replacement mode of nacos assigning the next member list, the implementation of merge management is replaced from the named module and the config module, unified to the addressing module of the core module, and the command line parameters are added at the same time -Dnacos.member.list **To set the list listed by nacos, this parameter can be called an alternative to the cluster.conf file. The current nacos addressing mode categories are as follows"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"In stand-alone mode: StandaloneMemberLookup"),(0,o.kt)("li",{parentName:"ol"},"Play mode",(0,o.kt)("ol",{parentName:"li"},(0,o.kt)("li",{parentName:"ol"},"The cluster.conf file exists: FileConfigMemberLookup"),(0,o.kt)("li",{parentName:"ol"},"The cluster.conf file does not exist or -Dnacos.member.list is not set: AddressServerMemberLookup")))),(0,o.kt)("p",null,"If you want to specify an addressing mode, set this parameter\uff1a",(0,o.kt)("strong",{parentName:"p"},"nacos.core.member.lookup.type=","[file,address-server]")),(0,o.kt)("p",null,"The logical diagram is as follows\n",(0,o.kt)("img",{parentName:"p",src:"https://cdn.nlark.com/yuque/__puml/e209a677aa8b5ffce23589e987ee5129.svg#lake_card_v2=eyJjb2RlIjoiQHN0YXJ0dW1sXG5cbigqKSAtLT4gXCJMb29rdXBGYWN0b3J5LmluaXQoKVwiXG5cbmlmIFwic3RhbmRhbG9uZSBtb2RlXCIgdGhlblxuICAtLT5bdHJ1ZV0gXCJyZXR1cm4gU3RhbmRhbG9uZU1lbWJlckxvb2t1cFwiXG4gIC0tPiBMb29rdXAucnVuKClcbmVsc2VcbiBpZiBcImNsdXN0ZXIuY29uZiBleGlzdHNcIiB0aGVuXG4gICAgLS0-W3RydWVdIFwicmV0dXJuIEZpbGVDb25maWdNZW1iZXJMb29rdXBcIlxuICAgIC0tPiBMb29rdXAucnVuKClcbiBlbHNlXG4gICAgLT5bZmFsc2VdIFwicmV0dXJuIEFkZHJlc3NTZXJ2ZXJNZW1iZXJMb29rdXBcIlxuICAgIC0tPiBMb29rdXAucnVuKClcbiBlbmRpZlxuZW5kaWZcblxuLS0-ICgqKVxuXG5AZW5kdW1sIiwidHlwZSI6InB1bWwiLCJpZCI6IlplWGtkIiwidXJsIjoiaHR0cHM6Ly9jZG4ubmxhcmsuY29tL3l1cXVlL19fcHVtbC9lMjA5YTY3N2FhOGI1ZmZjZTIzNTg5ZTk4N2VlNTEyOS5zdmciLCJjYXJkIjoiZGlhZ3JhbSJ9",alt:null})),(0,o.kt)("a",{name:"wqkMp"}),(0,o.kt)("h3",{id:"addressing-mode-details"},"Addressing mode details"),(0,o.kt)("p",null,"Next, I introduce two other addressing modes in addition to the addressing mode in stand-alone mode",(0,o.kt)("br",null)),(0,o.kt)("a",{name:"egl3H"}),(0,o.kt)("h4",{id:"fileconfigmemberlookup"},"FileConfigMemberLookup"),(0,o.kt)("p",null,"This addressing mode is managed based on the cluster.conf file, and each node will read the list of member nodes in the cluster.conf file under their respective ${nacos.home}/conf and then form a cluster. And after reading the cluster.conf file under ${nacos.home}/conf for the first time, it will automatically register a directory listener with the operating system's ",(0,o.kt)("em",{parentName:"p"},(0,o.kt)("strong",{parentName:"em"},"inotify"))," mechanism to monitor ${nacos.home}/ All file changes in the conf directory (note that only files will be monitored here, and file changes in subdirectories cannot be monitored)",(0,o.kt)("br",null),"When you need to expand or shrink the cluster nodes, you need to manually modify the content of the member node list of cluster.conf under ${nacos.home}/conf for each node."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},'private FileWatcher watcher = new FileWatcher() {\n        @Override\n        public void onChange(FileChangeEvent event) {\n            readClusterConfFromDisk();\n        }\n\n        @Override\n        public boolean interest(String context) {\n            return StringUtils.contains(context, "cluster.conf");\n        }\n};\n\n@Override\npublic void start() throws NacosException {\n    readClusterConfFromDisk();\n\n    if (memberManager.getServerList().isEmpty()) {\n        throw new NacosException(NacosException.SERVER_ERROR,\n                    "Failed to initialize the member node, is empty");\n    }\n\n    // Use the inotify mechanism to monitor file changes and automatically\n    // trigger the reading of cluster.conf\n    try {\n        WatchFileCenter.registerWatcher(ApplicationUtils.getConfFilePath(), watcher);\n    }\n    catch (Throwable e) {\n        Loggers.CLUSTER.error("An exception occurred in the launch file monitor : {}", e);\n    }\n}\n')),(0,o.kt)("p",null,"The first time you directly read the node list information in the cluster.conf file, then register a directory listener with WatchFileCenter, and automatically trigger ",(0,o.kt)("em",{parentName:"p"},(0,o.kt)("strong",{parentName:"em"},"readClusterConfFromDisk()"))," to re-read cluster.conf when the cluster.conf file changes file",(0,o.kt)("br",null),(0,o.kt)("img",{parentName:"p",src:"https://cdn.nlark.com/yuque/0/2020/png/333972/1591014354207-49c1e934-2aa5-465a-8a2b-0b09902814f8.png#align=left&display=inline&height=531&margin=%5Bobject%20Object%5D&name=image.png&originHeight=531&originWidth=1169&size=105696&status=done&style=none&width=1169",alt:"image.png"})),(0,o.kt)("a",{name:"yFTCl"}),(0,o.kt)("h4",{id:"addressservermemberlookup"},"AddressServerMemberLookup"),(0,o.kt)("p",null,"This addressing mode is based on an additional web server to manage cluster.conf. Each node periodically requests the content of the cluster.conf file from the web server, and then implements addressing between cluster nodes and expansion and contraction. ",(0,o.kt)("br",null),"When you need to expand or shrink the cluster, you only need to modify the cluster.conf file, and then each node will automatically get the latest cluster.conf file content when it requests the address server."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},'@Override\npublic void start() throws NacosException {\n    if (start.compareAndSet(false, true)) {\n        this.maxFailCount = Integer.parseInt(ApplicationUtils.getProperty("maxHealthCheckFailCount", "12"));\n        initAddressSys();\n        run();\n    }\n}\n\nprivate void initAddressSys() {\n    String envDomainName = System.getenv("address_server_domain");\n    if (StringUtils.isBlank(envDomainName)) {\n        domainName = System.getProperty("address.server.domain", "jmenv.tbsite.net");\n    } else {\n        domainName = envDomainName;\n    }\n    String envAddressPort = System.getenv("address_server_port");\n    if (StringUtils.isBlank(envAddressPort)) {\n        addressPort = System.getProperty("address.server.port", "8080");\n    } else {\n        addressPort = envAddressPort;\n    }\n    addressUrl = System.getProperty("address.server.url",\n                ApplicationUtils.getContextPath() + "/" + "serverlist");\n    addressServerUrl = "http://" + domainName + ":" + addressPort + addressUrl;\n    envIdUrl = "http://" + domainName + ":" + addressPort + "/env";\n\n    Loggers.CORE.info("ServerListService address-server port:" + addressPort);\n    Loggers.CORE.info("ADDRESS_SERVER_URL:" + addressServerUrl);\n}\n\n@SuppressWarnings("PMD.UndefineMagicConstantRule")\nprivate void run() throws NacosException {\n    // With the address server, you need to perform a synchronous member node pull at startup\n    // Repeat three times, successfully jump out\n    boolean success = false;\n    Throwable ex = null;\n    int maxRetry = ApplicationUtils.getProperty("nacos.core.address-server.retry", Integer.class, 5);\n    for (int i = 0; i < maxRetry; i ++) {\n        try {\n            syncFromAddressUrl();\n            success = true;\n            break;\n        } catch (Throwable e) {\n            ex = e;\n            Loggers.CLUSTER.error("[serverlist] exception, error : {}", ExceptionUtil.getAllExceptionMsg(ex));\n        }\n    }\n    if (!success) {\n        throw new NacosException(NacosException.SERVER_ERROR, ex);\n    }\n\n    GlobalExecutor.scheduleByCommon(new AddressServerSyncTask(), 5_000L);\n}\n')),(0,o.kt)("p",null,"During initialization, it will take the initiative to synchronize the current cluster member list information with the address server, and if it fails, retry, the maximum number of retries can be controlled by setting ",(0,o.kt)("em",{parentName:"p"},(0,o.kt)("strong",{parentName:"em"},"nacos.core.address-server.retry")),", The default is 5 times, and then after success, a scheduled task will be created to synchronize the cluster member node information to the address server",(0,o.kt)("br",null),(0,o.kt)("img",{parentName:"p",src:"https://cdn.nlark.com/yuque/0/2020/png/333972/1591014362972-004f5338-af0d-4d0d-b769-4f3d5118c08a.png#align=left&display=inline&height=846&margin=%5Bobject%20Object%5D&name=image.png&originHeight=846&originWidth=1149&size=188886&status=done&style=none&width=1149",alt:"image.png"})),(0,o.kt)("a",{name:"sgOTI"}),(0,o.kt)("h3",{id:"how-node-management-and-addressing-modes-are-combined"},"How node management and addressing modes are combined"),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://cdn.nlark.com/yuque/0/2020/png/333972/1591014400580-39b83aa0-c548-4241-a49e-0d72abda2a95.png#align=left&display=inline&height=715&margin=%5Bobject%20Object%5D&name=image.png&originHeight=715&originWidth=1189&size=131826&status=done&style=none&width=1189",alt:"image.png"}),(0,o.kt)("br",null),"After MemberLookup starts, it will perform addressing tasks according to different addressing modes, will collect cluster node list information, call memberChange, trigger cluster node changes, and then publish node change events"),(0,o.kt)("a",{name:"idHpC"}),(0,o.kt)("h2",{id:"nacos-consensus-protocol-protocol-layer-abstraction"},"Nacos consensus protocol protocol layer abstraction"),(0,o.kt)("p",null,"From the overall architecture of nacos in the future, it can be seen that the consistency protocol layer will be the core module of nacos, and will serve each functional module built on the core module, or the service and core module itself. The consistency protocol needs to choose between availability and consistency because of the existence of partition fault tolerance, so there are two major types of consistency: final consistency and strong consistency. In nacos, both types of consistency protocols are possible. For example, the naming module uses AP and CP for data management of service instances, respectively. For the config module, it will involve the use of CP. At the same time, there are the following functional demand points"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"At present, the persistence service uses a variant version of raft, and the business and the raft protocol are coupled. Therefore, it needs to be decoupled and decoupled. At the same time, a standard Java version of Raft is selected for implementation."),(0,o.kt)("li",{parentName:"ol"},"For small and medium-sized users, the configuration is basically not super much. An independent mysql is relatively heavy and requires a light-weight storage solution. It also supports 2.0 not dependent on mysql and 3.0 dependent on mysql configurability"),(0,o.kt)("li",{parentName:"ol"},"Due to CP or AP, there are many implementations, how to make a good abstraction of the consistency protocol layer, so that in the future can quickly achieve the specific implementation of the underlying consistency protocol replacement, such as the Raft protocol, the current selection of nacos It is JRaft, it is not excluded that in the future nacos will implement a standard raft protocol or Paxos protocol by itself"),(0,o.kt)("li",{parentName:"ol"},"Since there are multiple function modules working independently in Nacos, there can be no influence between each function module. For example, when the A module processes the request too slowly or an exception occurs, it cannot affect the normal operation of the B module, that is, each function module is in use. How to isolate the data processing of each module when using a consistent protocol?")),(0,o.kt)("p",null,"According to the consensus protocol and the above functional requirements, this time an abstract consensus protocol layer and related interfaces were made"),(0,o.kt)("a",{name:"3w8xM"}),(0,o.kt)("h3",{id:"consensus-agreement-abstraction"},"Consensus agreement abstraction"),(0,o.kt)("a",{name:"p7zRo"}),(0,o.kt)("h4",{id:"consistencyprotocol"},"ConsistencyProtocol"),(0,o.kt)("p",null,"The so-called consistency is the characteristic of whether multiple copies can maintain consistency, and the essence of the copy is data, and the operation of the data is either acquisition or modification. At the same time, the consensus protocol is actually for distributed situations, and this necessarily involves multiple nodes. Therefore, there is a need for a corresponding interface to be able to adjust the coordination protocol of the collaborative work node. What if we want to observe the operation of the consistency agreement? For example, the Raft protocol, we want to know who is the leader in the current cluster, the term of office, and who are the member nodes in the current cluster? Therefore, it is also necessary to provide a consistent protocol metadata acquisition. ",(0,o.kt)("br",null),"In summary, the general design of ConsistencyProtcol can come out"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"public interface ConsistencyProtocol<T extends Config, P extends LogProcessor> extends CommandOperations {\n\n    /**\n     * Consistency protocol initialization: perform initialization operations based on the incoming Config\n     * \u4e00\u81f4\u6027\u534f\u8bae\u521d\u59cb\u5316\uff0c\u6839\u636e Config \u5b9e\u73b0\u7c7b\n     *\n     * @param config {@link Config}\n     */\n    void init(T config);\n\n    /**\n     * Add a log handler\n     *\n     * @param processors {@link LogProcessor}\n     */\n    void addLogProcessors(Collection<P> processors);\n\n    /**\n     * Copy of metadata information for this consensus protocol\n     * \u8be5\u4e00\u81f4\u6027\u534f\u8bae\u7684\u5143\u6570\u636e\u4fe1\u606f\n     *\n     * @return metaData {@link ProtocolMetaData}\n     */\n    ProtocolMetaData protocolMetaData();\n\n    /**\n     * Obtain data according to the request\n     *\n     * @param request request\n     * @return data {@link Response}\n     * @throws Exception\n     */\n    Response getData(GetRequest request) throws Exception;\n\n    /**\n     * Get data asynchronously\n     *\n     * @param request request\n     * @return data {@link CompletableFuture<Response>}\n     */\n    CompletableFuture<Response> aGetData(GetRequest request);\n\n    /**\n     * Data operation, returning submission results synchronously\n     * \u540c\u6b65\u6570\u636e\u63d0\u4ea4\uff0c\u5728 Datum \u4e2d\u5df2\u643a\u5e26\u76f8\u5e94\u7684\u6570\u636e\u64cd\u4f5c\u4fe1\u606f\n     *\n     * @param data {@link Log}\n     * @return submit operation result {@link Response}\n     * @throws Exception\n     */\n    Response submit(Log data) throws Exception;\n\n    /**\n     * Data submission operation, returning submission results asynchronously\n     * \u5f02\u6b65\u6570\u636e\u63d0\u4ea4\uff0c\u5728 Datum \u4e2d\u5df2\u643a\u5e26\u76f8\u5e94\u7684\u6570\u636e\u64cd\u4f5c\u4fe1\u606f\uff0c\u8fd4\u56de\u4e00\u4e2aFuture\uff0c\u81ea\u884c\u64cd\u4f5c\uff0c\u63d0\u4ea4\u53d1\u751f\u7684\u5f02\u5e38\u4f1a\u5728CompleteFuture\u4e2d\n     *\n     * @param data {@link Log}\n     * @return {@link CompletableFuture<Response>} submit result\n     * @throws Exception when submit throw Exception\n     */\n    CompletableFuture<Response> submitAsync(Log data);\n\n    /**\n     * New member list\n     * \u65b0\u7684\u6210\u5458\u8282\u70b9\u5217\u8868\uff0c\u4e00\u81f4\u6027\u534f\u8bae\u81ea\u884c\u5904\u7406\u76f8\u5e94\u7684\u6210\u5458\u8282\u70b9\u662f\u52a0\u5165\u8fd8\u662f\u79bb\u5f00\n     *\n     * @param addresses [ip:port, ip:port, ...]\n     */\n    void memberChange(Set<String> addresses);\n\n    /**\n     * Consistency agreement service shut down\n     * \u4e00\u81f4\u6027\u534f\u8bae\u670d\u52a1\u5173\u95ed\n     */\n    void shutdown();\n\n}\n")),(0,o.kt)("p",null,"For the CP protocol, due to the concept of Leader, it is necessary to provide a method for obtaining who is the current Leader of the CP protocol."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"public interface CPProtocol<C extends Config> extends ConsistencyProtocol<C> {\n\n    /**\n     * Returns whether this node is a leader node\n     *\n     * @param group business module info\n     * @return is leader\n     * @throws Exception\n     */\n    boolean isLeader(String group) throws Exception;\n\n}\n")),(0,o.kt)("a",{name:"oJFpB"}),(0,o.kt)("h4",{id:"data-operation-request-submission-objectloggetrequest"},"Data operation request submission object\uff1aLog\u3001GetRequest"),(0,o.kt)("p",null,"As mentioned above, the consistency protocol is actually for data operations. Data operations are basically divided into two categories: data query and data modification, and at the same time, data isolation between different functional modules must be satisfied. Therefore, the data modification operations and data query operations are explained separately here."),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Data modification",(0,o.kt)("ol",{parentName:"li"},(0,o.kt)("li",{parentName:"ol"},"Data modification operation, you must know which functional module this request belongs to"),(0,o.kt)("li",{parentName:"ol"},"For data modification operations, you must first know what kind of modification operation this data modification operation is for, so that the function module can perform corresponding logical operations for the real data modification operation"),(0,o.kt)("li",{parentName:"ol"},"For data modification operations, you must know what the modified data is, that is, the request body. In order to make the consistency protocol layer more general, here for the data structure of the request body, the byte[] array is selected"),(0,o.kt)("li",{parentName:"ol"},"The type of data, because we serialize the real data into a byte[] array, in order to be able to serialize normally, we may also need to record what the type of this data is"),(0,o.kt)("li",{parentName:"ol"},"The information summary or identification information of this request"),(0,o.kt)("li",{parentName:"ol"},"The additional information for this request is used to expand the data to be transmitted in the future")))),(0,o.kt)("p",null,"In summary, it can be concluded that the design of the Log object is as follows"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-protobuf"},"\nmessage Log {\n    // Function module grouping information\n    string group = 1;\n    // Abstract or logo\n    string key = 2;\n    // Specific request data\n    bytes data = 3;\n    // type of data\n    string type = 4;\n    // More specific data manipulation\n    string operation = 5;\n    // extra information\n    map<string, string> extendInfo = 6;\n}\n")),(0,o.kt)("ol",{start:2},(0,o.kt)("li",{parentName:"ol"},"Data query",(0,o.kt)("ol",{parentName:"li"},(0,o.kt)("li",{parentName:"ol"},"For data query operations, you must know which function module initiated the request"),(0,o.kt)("li",{parentName:"ol"},"What are the conditions for data query? In order to be compatible with data query operations of various storage structures, here byte[] is used for storage"),(0,o.kt)("li",{parentName:"ol"},"The additional information for this request is used to expand the data to be transmitted in the future")))),(0,o.kt)("p",null,"In summary, the design of the GetRequest object is as follows"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-protobuf"},"message GetRequest {\n    // Function module grouping information\n    string group = 1;\n    // Specific request data\n    bytes data = 2;\n    // extra information\n    map<string, string> extendInfo = 3;\n}\n")),(0,o.kt)("a",{name:"vBig4"}),(0,o.kt)("h4",{id:"function-modules-use-consistency-protocollogprocessor"},"Function modules use consistency protocol\uff1aLogProcessor"),(0,o.kt)("p",null,"After the data operation is submitted through the consistency protocol, each node needs to process the Log or GetRequest object. Therefore, we need to abstract a Log and GetRequest object Processor. Different functional modules implement the processor. ConsistencyProtocol will internally According to the group attributes of Log and GetRequest, the Log and GetRequest objects are routed to a specific Processor. Of course, the Processor also needs to indicate which functional module it belongs to."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"public abstract class LogProcessor {\n\n    /**\n     * get data by key\n     *\n     * @param request request {@link GetRequest}\n     * @return target type data\n     */\n    public abstract Response onRequest(GetRequest request);\n\n    /**\n     * Process Submitted Log\n     *\n     * @param log {@link Log}\n     * @return {@link boolean}\n     */\n    public abstract Response onApply(Log log);\n\n    /**\n     * Irremediable errors that need to trigger business price cuts\n     *\n     * @param error {@link Throwable}\n     */\n    public void onError(Throwable error) {\n    }\n\n    /**\n     * In order for the state machine that handles the transaction to be able to route\n     * the Log to the correct LogProcessor, the LogProcessor needs to have an identity\n     * information\n     *\n     * @return Business unique identification name\n     */\n    public abstract String group();\n\n}\n")),(0,o.kt)("p",null,"For the CP protocol, such as the Raft protocol, there is a snapshot design, so we need to separately extend a method for the CP protocol"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"public abstract class LogProcessor4CP extends LogProcessor {\n\n    /**\n     * Discovery snapshot handler\n     * It is up to LogProcessor to decide which SnapshotOperate should be loaded and saved by itself\n     *\n     * @return {@link List <SnapshotOperate>}\n     */\n    public List<SnapshotOperation> loadSnapshotOperate() {\n        return Collections.emptyList();\n    }\n\n}\n")),(0,o.kt)("a",{name:"zbsAE"}),(0,o.kt)("h4",{id:"summary"},"Summary"),(0,o.kt)("p",null,"As can be seen from the above points, ConsistencyProtocol is the use interface exposed to the upper layer functional modules. Each ConsistencyProtocol has a backend implemented by a specific consistency protocol. Because Backend cannot be well compatible with nacos existing architecture design, so The additional LogProcessor is designed to solve this problem.",(0,o.kt)("br",null),(0,o.kt)("img",{parentName:"p",src:"https://cdn.nlark.com/yuque/0/2020/png/333972/1591015048030-8a4bff4a-20ed-46dd-a7f7-98655b22946f.png#align=left&display=inline&height=591&margin=%5Bobject%20Object%5D&name=image.png&originHeight=591&originWidth=886&size=93327&status=done&style=none&width=886",alt:"image.png"}),(0,o.kt)("br",null),"\u540cAt the time, because the backend inside the consistency protocol layer needs to implement the isolation processing of the data of different business modules, and this piece of logic is implemented by the request object and the group attribute of the LogProcessor",(0,o.kt)("br",null),(0,o.kt)("img",{parentName:"p",src:"https://cdn.nlark.com/yuque/0/2020/png/333972/1591015155835-a897262e-8e57-409c-bf94-d57bf765c80b.png#align=left&display=inline&height=591&margin=%5Bobject%20Object%5D&name=image.png&originHeight=591&originWidth=910&size=118083&status=done&style=none&width=910",alt:"image.png"})),(0,o.kt)("a",{name:"C1yU6"}),(0,o.kt)("h3",{id:"consistent-protocol-layer-workflow"},"Consistent protocol layer workflow"),(0,o.kt)("p",null,"We can take a look at a sequence diagram, the general workflow of the consistency protocol layer\n",(0,o.kt)("img",{parentName:"p",src:"https://cdn.nlark.com/yuque/__puml/30b7e270e7aef8bb63136aaffbe5bfbf.svg#lake_card_v2=eyJjb2RlIjoiQHN0YXJ0dW1sXG5cbnBhcnRpY2lwYW50IFwiTWVtYmVyTWFuYWdlclwiIGFzIE5hY29zQ2x1c3RlclxucGFydGljaXBhbnQgXCJCdXNpbmVzc01vZHVsZVwiIGFzIEJpelxucGFydGljaXBhbnQgXCJDb25zaXN0ZW5jeVByb3RvY29sXCIgYXMgUHJvdG9jb2xcbnBhcnRpY2lwYW50IFwiQ0FQQmFja2VuZFwiIGFzIEJhY2tlbmRcbnBhcnRpY2lwYW50IFwiQ29uZmlnXCIgYXMgQ29uZmlnXG5wYXJ0aWNpcGFudCBcIkxvZ1Byb2Nlc3NvclwiIGFzIFByb2Nlc3NvclxucGFydGljaXBhbnQgXCJMb2dcIiBhcyBMb2dcblxuYWN0aXZhdGUgTmFjb3NDbHVzdGVyXG5OYWNvc0NsdXN0ZXIgLT4gTmFjb3NDbHVzdGVyOiBpbml0KCkg5Yid5aeL5YyWTmFjb3Ppm4bnvqRcblxuTmFjb3NDbHVzdGVyIC0-IENvbmZpZzog6I635Y-WQ29uZmln5a-56LGhXG5hY3RpdmF0ZSBDb25maWdcbkNvbmZpZyAtPiBDb25maWc6IOaUtumbhkxvZ1Byb2Nlc3NvcueahOS_oeaBr1xuQ29uZmlnIC0-IE5hY29zQ2x1c3RlclxuZGVhY3RpdmF0ZSBDb25maWdcblxuXG5OYWNvc0NsdXN0ZXIgLT4gUHJvdG9jb2w6IOiOt-WPluaJgOaciUNvbnNpc3RlbmN5UHJvdG9jb2zlrp7njrBcbmFjdGl2YXRlIFByb3RvY29sXG5cbk5hY29zQ2x1c3RlciAtPiBQcm90b2NvbDogaW5pdChDb25maWcpIOaWueazleaJp-ihjFxuXG5kZWFjdGl2YXRlIFByb3RvY29sXG5kZWFjdGl2YXRlIE5hY29zQ2x1c3RlclxuXG5cbkJpeiAtPiBMb2c6IOWIm-W7uuS4gOS4quS6i-WKoeWvueixoVxuYWN0aXZhdGUgQml6XG5hY3RpdmF0ZSBMb2dcblxuXG5Mb2cgLT4gTG9nOiDorr7nva5kYXRhXG5Mb2cgLT4gTG9nOiDorr7nva5rZXlcbkxvZyAtPiBMb2c6IOiuvue9rmNsYXNzTmFtZVxuTG9nIC0-IExvZzog6K6-572uZXh0ZW5kSW5mb1xuTG9nIC0-IEJpelxuZGVhY3RpdmF0ZSBMb2dcblxuQml6IC0-IFByb3RvY29sOiBzdWJtaXQoTG9nKSDosIPnlKjkuIDoh7TmgKfljY_orq7ov5vooYzkuovliqHmj5DkuqRcbmFjdGl2YXRlIFByb3RvY29sXG5cblByb3RvY29sIC0-IEJhY2tlbmQ6IOWGhemDqOS4gOiHtOaAp-WNj-iuruW3peS9nFxuYWN0aXZhdGUgQmFja2VuZFxuXG5CYWNrZW5kIC0-IFByb3RvY29sOiDov5Tlm57lt6XkvZzlpITnkIbnu5PmnpxcbmRlYWN0aXZhdGUgQmFja2VuZFxuXG5Qcm90b2NvbCAtPiBQcm9jZXNzb3I6IOWwhkxvZ-WIhuWPkeWIsOWvueW6lOeahFByb2Nlc3Nvcu-8jOiwg-eUqCBvbkFwcGx5IOaWueazlVxuYWN0aXZhdGUgUHJvdG9jb2xcbmRlYWN0aXZhdGUgUHJvdG9jb2xcblxuUHJvY2Vzc29yIC0-IEJpejog5LqL5Yqh5o-Q5Lqk57uT5p6cXG5cbmRlYWN0aXZhdGUgUHJvY2Vzc29yXG5kZWFjdGl2YXRlIEJpelxuXG5AZW5kdW1sIiwidHlwZSI6InB1bWwiLCJtYXJnaW4iOnRydWUsImlkIjoiNFZpMkwiLCJ1cmwiOiJodHRwczovL2Nkbi5ubGFyay5jb20veXVxdWUvX19wdW1sLzMwYjdlMjcwZTdhZWY4YmI2MzEzNmFhZmZiZTViZmJmLnN2ZyIsImNhcmQiOiJkaWFncmFtIn0=",alt:null})),(0,o.kt)("a",{name:"xtBNU"}),(0,o.kt)("h3",{id:"the-implementation-option-of-cp-protocol-in-nacos-consistency-protocol-layerjraft"},"The implementation option of CP protocol in Nacos consistency protocol layer\u2014\u2014JRaft"),(0,o.kt)("p",null,"After the consistency protocol layer is abstracted, the rest is the choice of concrete consistency protocol implementation. Here we have chosen Ant Financial's open source JRaft, so how can we use JRaf as a backend of the CP protocol? The following simple flow chart describes the initialization process when JRaft is used as a Backend of the CP protocol"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},'/**\n * A concrete implementation of CP protocol: JRaft\n *\n * <pre>\n *                                           \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510               \n *                                           \u2502                      \u2502               \n *            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510       \u2502                      \u25bc               \n *            \u2502   ProtocolManager    \u2502       \u2502        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \n *            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2502        \u2502for p in [LogProcessor4CP] \u2502 \n *                        \u2502                  \u2502        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \n *                        \u25bc                  \u2502                      \u2502               \n *      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502                      \u25bc               \n *      \u2502    discovery LogProcessor4CP     \u2502 \u2502             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \n *      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502             \u2502  get p.group()  \u2502      \n *                        \u2502                  \u2502             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \n *                        \u25bc                  \u2502                      \u2502               \n *                 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510           \u2502                      \u2502               \n *                 \u2502 RaftConfig  \u2502           \u2502                      \u25bc               \n *                 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518           \u2502      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n *                        \u2502                  \u2502      \u2502  create raft group service   \u2502\n *                        \u25bc                  \u2502      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n *              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510         \u2502                                      \n *              \u2502  JRaftProtocol   \u2502         \u2502                                      \n *              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518         \u2502                                      \n *                        \u2502                  \u2502                                      \n *                     init()                \u2502                                      \n *                        \u2502                  \u2502                                      \n *                        \u25bc                  \u2502                                      \n *               \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510         \u2502                                      \n *               \u2502   JRaftServer   \u2502         \u2502                                      \n *               \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518         \u2502                                      \n *                        \u2502                  \u2502                                      \n *                        \u2502                  \u2502                                      \n *                        \u25bc                  \u2502                                      \n *             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510        \u2502                                      \n *             \u2502JRaftServer.start() \u2502        \u2502                                      \n *             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518        \u2502                                      \n *                        \u2502                  \u2502                                      \n *                        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                      \n * </pre>\n * \n * @author <a href="mailto:liaochuntao@live.com">liaochuntao</a>\n */\n')),(0,o.kt)("p",null,"JRaftProtocol is a concrete implementation of a ConsistencyProtocol when JRaft is used as the backend of the CP protocol. It has a JRaftServer member attribute inside. JRaftServer distributes various API operations of JRaft, such as data operation submission, data query, and member node changes. , Leader node query, etc."),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},(0,o.kt)("strong",{parentName:"em"},"Note: The data generated during JRaft operation is in the ${nacos.home}/data/protocol/raft file directory. Different business modules have different file groupings. If the node crashes or shuts down abnormally, clear the files in the directory and restart the node"))),(0,o.kt)("p",null,"Since JRaft implements the concept of raft group, it is possible to use the design of raft group to create a raft group for each function module. Here is part of the code, which shows how to embed LogProcessor in the state machine and create a Raft Group for each LogPrcessor"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},'synchronized void createMultiRaftGroup(Collection<LogProcessor4CP> processors) {\n    // There is no reason why the LogProcessor cannot be processed because of the synchronization\n    if (!this.isStarted) {\n        this.processors.addAll(processors);\n        return;\n    }\n\n    final String parentPath = Paths\n                .get(ApplicationUtils.getNacosHome(), "data/protocol/raft").toString();\n\n    for (LogProcessor4CP processor : processors) {\n        final String groupName = processor.group();\n        if (multiRaftGroup.containsKey(groupName)) {\n            throw new DuplicateRaftGroupException(groupName);\n        }\n\n        // Ensure that each Raft Group has its own configuration and NodeOptions\n        Configuration configuration = conf.copy();\n        NodeOptions copy = nodeOptions.copy();\n        JRaftUtils.initDirectory(parentPath, groupName, copy);\n\n        // Here, the LogProcessor is passed into StateMachine, and when the StateMachine\n        // triggers onApply, the onApply of the LogProcessor is actually called\n        NacosStateMachine machine = new NacosStateMachine(this, processor);\n\n        copy.setFsm(machine);\n        copy.setInitialConf(configuration);\n\n        // Set snapshot interval, default 1800 seconds\n        int doSnapshotInterval = ConvertUtils.toInt(raftConfig\n                            .getVal(RaftSysConstants.RAFT_SNAPSHOT_INTERVAL_SECS),\n                    RaftSysConstants.DEFAULT_RAFT_SNAPSHOT_INTERVAL_SECS);\n\n        // If the business module does not implement a snapshot processor, cancel the snapshot\n        doSnapshotInterval = CollectionUtils\n                    .isEmpty(processor.loadSnapshotOperate()) ? 0 : doSnapshotInterval;\n\n        copy.setSnapshotIntervalSecs(doSnapshotInterval);\n        Loggers.RAFT.info("create raft group : {}", groupName);\n        RaftGroupService raftGroupService = new RaftGroupService(groupName,\n                    localPeerId, copy, rpcServer, true);\n\n        // Because RpcServer has been started before, it is not allowed to start again here\n        Node node = raftGroupService.start(false);\n        machine.setNode(node);\n        RouteTable.getInstance().updateConfiguration(groupName, configuration);\n        RaftExecutor.executeByCommon(() -> registerSelfToCluster(groupName, localPeerId, configuration));\n\n        // Turn on the leader auto refresh for this group\n        Random random = new Random();\n        long period = nodeOptions.getElectionTimeoutMs() + random.nextInt(5 * 1000);\n        RaftExecutor.scheduleRaftMemberRefreshJob(() -> refreshRouteTable(groupName),\n                    nodeOptions.getElectionTimeoutMs(), period, TimeUnit.MILLISECONDS);\n        multiRaftGroup.put(groupName,\n                    new RaftGroupTuple(node, processor, raftGroupService, machine));\n    }\n}\n')),(0,o.kt)("a",{name:"4czvB"}),(0,o.kt)("h4",{id:"qa-why-do-you-want-to-create-multiple-raft-groups"},"Q&A: Why do you want to create multiple raft groups"),(0,o.kt)("p",null,"Some people may have doubts. Since the LogProcessor has been designed before, you can use a Raft Group. When the state machine is appl, you can route to different LogProcessors according to the Log group attribute. Each function module creates a Raft group, will it consume a lot of resources? ",(0,o.kt)("br",null),"As mentioned before, we hope that the modules that work independently do not affect each other. For example, the A module processing Log may cause the application speed to be slow because of the Block operation, or an exception may occur halfway. For the Raft protocol , When the log apply fails, the state machine will not be able to continue to move forward, because if you continue to move forward, due to the previous step of the apply failure, all subsequent applications may fail, which will cause the data of this node and other nodes Data is never consistent. If we put all the modules that work independently in the same raft group, that is, a state machine, for the data processing request processing, the above-mentioned problems will inevitably occur, and a module will be uncontrollable in the apply log. Factors will affect the normal operation of other modules."),(0,o.kt)("a",{name:"2GyRw"}),(0,o.kt)("h3",{id:"jraft-operation-and-maintenance"},"JRaft operation and maintenance"),(0,o.kt)("p",null,"In order to allow users to perform simple operation and maintenance of JRaft, such as leader switching, resetting the current Raft cluster members, triggering a node to perform Snapshot operations, etc., a simple HTTP interface is provided for operation, and the interface has certain Limit, that is, only one operation instruction can be executed at a time"),(0,o.kt)("p",null,"1\u3001Switch the leader node of a certain Raft Group"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},'POST /nacos/v1/core/ops/raft\n{\n    "groupId": "xxx",\n    "command": "transferLeader"\n    "value": "ip:{raft_port} or ip:{raft_port},ip:{raft_port},ip:{raft_port}"\n}\n')),(0,o.kt)("a",{name:"Fs7VE"}),(0,o.kt)("p",null,"2\u3001Reset a Raft Group cluster member"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},'POST /nacos/v1/core/ops/raft\n{\n    "groupId": "xxx",\n    "command": "resetRaftCluster",\n    "value": "ip:{raft_port},ip:{raft_port},ip:{raft_port},ip:{raft_port}"\n}\n')),(0,o.kt)("p",null,"Note that this operation is a high-risk operation. This operation and maintenance command can only be used when the n/2 + 1 node of the Raft cluster fails to meet the requirements of more than half of the vote after the crash. It is used to quickly reorganize the remaining nodes to the Raft cluster to provide external Service, but this operation will greatly cause the loss of data",(0,o.kt)("br",null)),(0,o.kt)("a",{name:"VfG5T"}),(0,o.kt)("p",null,"3\u3001Trigger a Raft Group to perform a snapshot operation"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},'POST /nacos/v1/core/ops/raft\n{\n    "groupId": "xxx",\n    "command": "doSnapshot",\n    "value": "ip:{raft_port}"\n}\n')),(0,o.kt)("a",{name:"m9LfI"}),(0,o.kt)("p",null,"4\u3001Remove a member of a Raft Group"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},'POST /nacos/v1/core/ops/raft\n{\n    "groupId": "xxx",\n    "command": "removePeer",\n    "value": "ip:{raft_port}"\n}\n')),(0,o.kt)("a",{name:"ev3MW"}),(0,o.kt)("p",null,"5\u3001Remove multiple members of a Raft Group in batches"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},'POST /nacos/v1/core/ops/raft\n{\n    "groupId": "xxx",\n    "command": "removePeers",\n    "value": "ip:{raft_port},ip:{raft_port},ip:{raft_port},..."\n}\n')),(0,o.kt)("a",{name:"GzMuP"}),(0,o.kt)("h3",{id:"jraft-protocol-related-configuration-parameters"},"JRaft protocol related configuration parameters"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml"},"### Sets the Raft cluster election timeout, default value is 5 second\nnacos.core.protocol.raft.data.election_timeout_ms=5000\n### Sets the amount of time the Raft snapshot will execute periodically, default is 30 minute\nnacos.core.protocol.raft.data.snapshot_interval_secs=30\n### Requested retries, default value is 1\nnacos.core.protocol.raft.data.request_failoverRetries=1\n### raft internal worker threads\nnacos.core.protocol.raft.data.core_thread_num=8\n### Number of threads required for raft business request processing\nnacos.core.protocol.raft.data.cli_service_thread_num=4\n### raft linear read strategy, defaults to index\nnacos.core.protocol.raft.data.read_index_type=ReadOnlySafe\n### rpc request timeout, default 5 seconds\nnacos.core.protocol.raft.data.rpc_request_timeout_ms=5000\n")),(0,o.kt)("h4",{id:"linear-reading-parameter-analysis"},"Linear reading parameter analysis"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"ReadOnlySafe"),(0,o.kt)("ol",{parentName:"li"},(0,o.kt)("li",{parentName:"ol"},"In this linear read mode, every time a Follower makes a read request, it needs to synchronize with the Leader to submit the site information, and the Leader needs to initiate a lightweight RPC request to prove that it is the Leader to more than half of the Follower, which is equivalent to a Follower read, at least 1 + (n/2) + 1 RPC request is required."))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"ReadOnlyLeaseBased"),(0,o.kt)("ol",{parentName:"li"},(0,o.kt)("li",{parentName:"ol"},"In this linear read mode, each time the Follower makes a read request, the Leader only needs to determine whether its Leader lease has expired. If it does not expire, it can directly reply that the Follower is the Leader, but the mechanism has strict requirements on the machine clock. For clock synchronization, consider using this linear read mode.")))),(0,o.kt)("a",{name:"WiLDa"}),(0,o.kt)("h2",{id:"nacos-embedded-distributed-id"},"Nacos embedded distributed ID"),(0,o.kt)("p",null,"The distributed ID embedded in nacos is Snakeflower, the dataCenterId defaults to 1, and the value of workerId is calculated as follows"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml"},'InetAddress address;\ntry {\n    address = InetAddress.getLocalHost();\n} catch (final UnknownHostException e) {\n    throw new IllegalStateException(\n                        "Cannot get LocalHost InetAddress, please check your network!");\n}\nbyte[] ipAddressByteArray = address.getAddress();\nworkerId = (((ipAddressByteArray[ipAddressByteArray.length - 2] & 0B11)\n                    << Byte.SIZE) + (ipAddressByteArray[ipAddressByteArray.length - 1]\n                    & 0xFF));\n')),(0,o.kt)("p",null,"If you need to manually specify dataCenterId and workerId, add command line parameters in application.properties or startup"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml"},"### set the dataCenterID manually\n# nacos.core.snowflake.data-center=\n### set the WorkerID manually\n# nacos.core.snowflake.worker-id=\n")),(0,o.kt)("a",{name:"ZLp5w"}),(0,o.kt)("h2",{id:"nacos-embedded-lightweight-derby-based-distributed-relational-storage"},"Nacos embedded lightweight Derby-based distributed relational storage"),(0,o.kt)("a",{name:"1B5KV"}),(0,o.kt)("h3",{id:"background"},"Background"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"If the number of configuration files is small, the cost of supporting a highly available database cluster in the cluster mode is too large, and it is expected to have a lightweight distributed relational storage to solve"),(0,o.kt)("li",{parentName:"ol"},"Some metadata information storage inside nacos, such as user information, namespace information"),(0,o.kt)("li",{parentName:"ol"},"Source of ideas:",(0,o.kt)("a",{parentName:"li",href:"https://github.com/rqlite/rqlite"},"https://github.com/rqlite/rqlite"))),(0,o.kt)("a",{name:"Du2qc"}),(0,o.kt)("h3",{id:"design-ideas"},"Design ideas"),(0,o.kt)("a",{name:"NzxHa"}),(0,o.kt)("h4",{id:"aims"},"aims"),(0,o.kt)("p",null,"The design goal is to expect nacos to have two data storage modes, one is the current way, the data is stored in an external data source (relational database); the second way is the embedded storage data source (Apache Derby). Users can use the command line parameter configuration to freely use these two data storage modes",(0,o.kt)("br",null),(0,o.kt)("img",{parentName:"p",src:"https://cdn.nlark.com/yuque/0/2020/png/333972/1591015542106-f14d2579-229f-4bfb-a432-e40854e65d6d.png#align=left&display=inline&height=903&margin=%5Bobject%20Object%5D&name=image.png&originHeight=903&originWidth=1514&size=237497&status=done&style=none&width=1514",alt:"image.png"})),(0,o.kt)("a",{name:"LqUtU"}),(0,o.kt)("h4",{id:"overall"},"overall"),(0,o.kt)("p",null,"Save the SQL context involved in a request operation in order. Then synchronize the SQL context involved in this request through the consensus protocol layer, and then each node parses it and executes it again in a database session in sequence.",(0,o.kt)("br",null),(0,o.kt)("img",{parentName:"p",src:"https://cdn.nlark.com/yuque/0/2020/png/333972/1587204104465-2270480a-de25-4c84-a11b-6edd2de99e66.png#align=left&display=inline&height=814&margin=%5Bobject%20Object%5D&name=%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6%20%281%29.png&originHeight=814&originWidth=1149&size=130886&status=done&style=none&width=1149",alt:"\u672a\u547d\u540d\u6587\u4ef6 (1).png"})),(0,o.kt)("a",{name:"yxFYn"}),(0,o.kt)("h4",{id:"related-data-bearing-objects"},"Related data bearing objects"),(0,o.kt)("p",null,"The DML statements of the database are select, insert, update, and delete. According to the nature of SQL statements for data operations, they can be divided into two categories: query and update. The select statement corresponds to data query, and the insert, update, and delete statements correspond to Data modification. At the same time, when performing database operations, in order to avoid SQL injection, PreparedStatement is used, so SQL statements + parameters are required, so two Request objects about database operations can be obtained"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"SelectRequest")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"public class SelectRequest implements Serializable {\n\n    private static final long serialVersionUID = 2212052574976898602L;\n    // Query category, because currently using JdbcTemplate, query a single, multiple queries, whether to use RowMapper into an object\n    private byte queryType;\n    // sql\u8bed\u53e5\n    // select * from config_info where\n    private String sql;\n    private Object[] args;\n    private String className;\n}\n")),(0,o.kt)("ol",{start:2},(0,o.kt)("li",{parentName:"ol"},"ModifyRequest")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"public class ModifyRequest implements Serializable {\n\n    private static final long serialVersionUID = 4548851816596520564L;\n\n    private int executeNo;\n    private String sql;\n    private Object[] args;\n}\n")),(0,o.kt)("a",{name:"moKl7"}),(0,o.kt)("h4",{id:"configure-publishing"},"Configure publishing"),(0,o.kt)("p",null,"The configuration release operation involves three transactions:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"config_info saves configuration information"),(0,o.kt)("li",{parentName:"ol"},"config_tags_relation saves the association relationship between configuration and tags"),(0,o.kt)("li",{parentName:"ol"},"his_config_info saves a history of configuration operations")),(0,o.kt)("p",null,"These three transactions are all configured and released under this big transaction. If we say that we perform a Raft protocol submission for each transaction operation, assume that 1, 2 transactions are successfully applied after being submitted through Raft, and the third transaction is in Raft. Apply fails after submission, then for the big transaction released by this configuration, it needs to be rolled back as a whole, otherwise it will violate the atomicity, then it may be necessary to say that the transaction rollback operation is again Raft submitted, then the overall complexity Rise, and directly introduce the management of distributed transactions, so in order to avoid this problem, we integrate the SQL contexts involved in these three transactions into a large SQL context, and submit the Raft protocol to this large SQL context. It ensures that the three sub-transactions successfully solve the atomicity problem in the same database session. At the same time, because the Raft protocol processes the transaction log serially, it is equivalent to adjusting the transaction isolation level of the database to serialization."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},'public void addConfigInfo(final String srcIp,\n            final String srcUser, final ConfigInfo configInfo, final Timestamp time,\n            final Map<String, Object> configAdvanceInfo, final boolean notify) {\n\n    try {\n        final String tenantTmp = StringUtils.isBlank(configInfo.getTenant()) ?\n                    StringUtils.EMPTY :\n                    configInfo.getTenant();\n        configInfo.setTenant(tenantTmp);\n        \n        // Obtain the database primary key through the snowflake ID algorithm\n        long configId = idGeneratorManager.nextId(RESOURCE_CONFIG_INFO_ID);\n        long hisId = idGeneratorManager.nextId(RESOURCE_CONFIG_HISTORY_ID);\n\n        addConfigInfoAtomic(configId, srcIp, srcUser, configInfo, time,\n                    configAdvanceInfo);\n        String configTags = configAdvanceInfo == null ?\n                    null :\n                    (String) configAdvanceInfo.get("config_tags");\n\n        addConfigTagsRelation(configId, configTags, configInfo.getDataId(),\n                    configInfo.getGroup(), configInfo.getTenant());\n        insertConfigHistoryAtomic(hisId, configInfo, srcIp, srcUser, time, "I");\n        EmbeddedStorageContextUtils.onModifyConfigInfo(configInfo, srcIp, time);\n        databaseOperate.blockUpdate();\n    }\n    finally {\n        EmbeddedStorageContextUtils.cleanAllContext();\n    }\n}\n\npublic long addConfigInfoAtomic(final long id, final String srcIp,\n            final String srcUser, final ConfigInfo configInfo, final Timestamp time,\n            Map<String, Object> configAdvanceInfo) {\n    ...\n    // \u53c2\u6570\u5904\u7406\n    ...\n    final String sql =\n                "INSERT INTO config_info(id, data_id, group_id, tenant_id, app_name, content, md5, src_ip, src_user, gmt_create,"\n                        + "gmt_modified, c_desc, c_use, effect, type, c_schema) VALUES(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)";\n    final Object[] args = new Object[] { id, configInfo.getDataId(),\n                configInfo.getGroup(), tenantTmp, appNameTmp, configInfo.getContent(),\n                md5Tmp, srcIp, srcUser, time, time, desc, use, effect, type, schema, };\n    SqlContextUtils.addSqlContext(sql, args);\n    return id;\n}\n\npublic void addConfigTagRelationAtomic(long configId, String tagName, String dataId,\n            String group, String tenant) {\n    final String sql =\n                "INSERT INTO config_tags_relation(id,tag_name,tag_type,data_id,group_id,tenant_id) "\n                        + "VALUES(?,?,?,?,?,?)";\n    final Object[] args = new Object[] { configId, tagName, null, dataId, group,\n                tenant };\n    SqlContextUtils.addSqlContext(sql, args);\n}\n\npublic void insertConfigHistoryAtomic(long configHistoryId, ConfigInfo configInfo,\n            String srcIp, String srcUser, final Timestamp time, String ops) {\n    ...\n    // \u53c2\u6570\u5904\u7406\n    ...\n    final String sql =\n                "INSERT INTO his_config_info (id,data_id,group_id,tenant_id,app_name,content,md5,"\n                        + "src_ip,src_user,gmt_modified,op_type) VALUES(?,?,?,?,?,?,?,?,?,?,?)";\n    final Object[] args = new Object[] { configHistoryId, configInfo.getDataId(),\n                configInfo.getGroup(), tenantTmp, appNameTmp, configInfo.getContent(),\n                md5Tmp, srcIp, srcUser, time, ops };\n\n    SqlContextUtils.addSqlContext(sql, args);\n}\n\n/**\n * Temporarily saves all insert, update, and delete statements under\n * a transaction in the order in which they occur\n *\n * @author <a href="mailto:liaochuntao@live.com">liaochuntao</a>\n */\npublic class SqlContextUtils {\n\n    private static final ThreadLocal<ArrayList<ModifyRequest>> SQL_CONTEXT =\n            ThreadLocal.withInitial(ArrayList::new);\n\n    public static void addSqlContext(String sql, Object... args) {\n        ArrayList<ModifyRequest> requests = SQL_CONTEXT.get();\n        ModifyRequest context = new ModifyRequest();\n        context.setExecuteNo(requests.size());\n        context.setSql(sql);\n        context.setArgs(args);\n        requests.add(context);\n        SQL_CONTEXT.set(requests);\n    }\n\n    public static List<ModifyRequest> getCurrentSqlContext() {\n        return SQL_CONTEXT.get();\n    }\n\n    public static void cleanCurrentSqlContext() {\n        SQL_CONTEXT.remove();\n    }\n\n}\n')),(0,o.kt)("p",null,"A more intuitive understanding through a timing diagram\n",(0,o.kt)("img",{parentName:"p",src:"https://cdn.nlark.com/yuque/__puml/618e8997395fbc74433ac4a60f67b6b4.svg#lake_card_v2=eyJjb2RlIjoiQHN0YXJ0dW1sXG5cbmF1dG9udW1iZXJcblxuYWN0b3IgXCJVc2VyXCIgYXMgVXNlclxuXG5wYXJ0aWNpcGFudCBcIkNvbmZpZ1NlcnZpY2VcIiBhcyBTZXJ2aWNlXG5wYXJ0aWNpcGFudCBcIlBlcnNpc3RlbmNlU2VydmljZVwiIGFzIFJlcG9zaXRvcnlcbnBhcnRpY2lwYW50IFwiRGVyYnlcIiBhcyBEQlxucGFydGljaXBhbnQgXCJTUUxDb250ZXh0VXRpbHNcIiBhcyBTUUxDb250ZXh0XG5wYXJ0aWNpcGFudCBcIkxvZ1Byb2Nlc3NvclwiIGFzIFByb2Nlc3NvclxucGFydGljaXBhbnQgXCJDb25zaXN0ZW5jeVByb3RvY29sXCIgYXMgUHJvdG9jb2xcbnBhcnRpY2lwYW50IFwiTG9nXCIgYXMgTG9nXG5cbmFjdGl2YXRlIFVzZXJcblxuVXNlciAtPiBTZXJ2aWNlOiDlj5HotbfphY3nva7lj5HluIPor7fmsYJcbmFjdGl2YXRlIFNlcnZpY2VcblxuU2VydmljZSAtPiBSZXBvc2l0b3J5OiDphY3nva7lj5HluINcbmFjdGl2YXRlIFJlcG9zaXRvcnlcblxuUmVwb3NpdG9yeSAtPiBTUUxDb250ZXh0OiDmi6bmiKrlvZPliY1TUUzkuIrkuIvmlodcbmFjdGl2YXRlIFNRTENvbnRleHRcblxuUmVwb3NpdG9yeSAtPiBSZXBvc2l0b3J5OiBjb21taXQg5pON5L2cXG5cblNRTENvbnRleHQgLT4gUmVwb3NpdG9yeTog5b2T5YmN6K-35rGC5raJ5Y-K55qE5omA5pyJU1FM5LiK5LiL5paHXG5cbmRlYWN0aXZhdGUgU1FMQ29udGV4dFxuXG5SZXBvc2l0b3J5IC0-IExvZzog5p6E5bu66K-35rGC5L2TXG5cbmFjdGl2YXRlIExvZ1xuZGVhY3RpdmF0ZSBMb2dcblxuUmVwb3NpdG9yeSAtPiBQcm90b2NvbDogc3VibWl0KCkg6L-b6KGM6K-35rGC5o-Q5LqkXG5hY3RpdmF0ZSBQcm90b2NvbFxuZGVhY3RpdmF0ZSBSZXBvc2l0b3J5XG5cblByb3RvY29sIC0-IFByb2Nlc3Nvcjogb25BcHBseSgpIOaWueazle-8jOeKtuaAgeacuuWkjeWItkxvZ1xuYWN0aXZhdGUgUHJvY2Vzc29yXG5cblByb2Nlc3NvciAtPiBSZXBvc2l0b3J5OiDmiafooYzmiYDmnInnmoRTUUzkuIrkuIvmlodcbmFjdGl2YXRlIFJlcG9zaXRvcnlcblxuUmVwb3NpdG9yeSAtPiBEQjog5pWw5o2u6JC95bqTXG5hY3RpdmF0ZSBEQlxuXG5EQiAtPiBSZXBvc2l0b3J5OiDnu5PmnZ_lubbov5Tlm57nu5PmnpxcbmRlYWN0aXZhdGUgREJcblxuUmVwb3NpdG9yeSAtPiBQcm9jZXNzb3I6IOi_lOWbnkxvZ0Z1dHVyZeW5tuiuvue9ruacrOasoeaJp-ihjOeahOe7k-aenFxuZGVhY3RpdmF0ZSBSZXBvc2l0b3J5XG5cblByb2Nlc3NvciAtPiBQcm90b2NvbDog6L-U5ZueTG9nRnV0dXJlXG5kZWFjdGl2YXRlIFByb2Nlc3NvclxuXG5Qcm90b2NvbCAtPiBTZXJ2aWNlOiDmnKzmrKHor7fmsYLnmoTnu5PmnpxcbmRlYWN0aXZhdGUgUHJvdG9jb2xcblxuU2VydmljZSAtPiBVc2VyXG5kZWFjdGl2YXRlIFNlcnZpY2VcbmRlYWN0aXZhdGUgVXNlclxuXG5AZW5kdW1sIiwidHlwZSI6InB1bWwiLCJtYXJnaW4iOnRydWUsImlkIjoiVnQxNzciLCJ1cmwiOiJodHRwczovL2Nkbi5ubGFyay5jb20veXVxdWUvX19wdW1sLzYxOGU4OTk3Mzk1ZmJjNzQ0MzNhYzRhNjBmNjdiNmI0LnN2ZyIsImNhcmQiOiJkaWFncmFtIn0=",alt:null})),(0,o.kt)("a",{name:"AAJTE"}),(0,o.kt)("h3",{id:"how-to-use-new-features"},"How to use new features"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"./startup.sh -p embedded\n")),(0,o.kt)("p",null,"Whether to enable the embedded distributed relational storage activity diagram\n",(0,o.kt)("img",{parentName:"p",src:"https://cdn.nlark.com/yuque/__puml/1fd656ba3b39fe5de8fea78efdf98dd1.svg#lake_card_v2=eyJjb2RlIjoiQHN0YXJ0dW1sXG5cbigqKSAtLT4gXCJDb25maWcuc3RhcnQoKVwiXG5cbmlmIFwi5Y2V5py65qih5byPXCIgdGhlblxuICAtcmlnaHQtPlt0cnVlXSBcInJldHVybiDpu5jorqTljZXmnLrlrZjlgqjooYzkuLpcIlxuICAtLT4gKCopXG5lbHNlXG4gaWYgXCLlt7LphY3nva7lpJbnva7lrZjlgqhcIiB0aGVuXG4gICAgLS0-W3RydWVdIFwicmV0dXJuIOWklue9ruaVsOaNruWtmOWCqOihjOS4ulwiXG4gICAgLS0-ICgqKVxuIGVsc2VcbiAgICBpZiBcIuW8gOWQr-WGheW1jOWtmOWCqFwiIHRoZW5cbiAgICAgICAgLS0-W3RydWVdIFwicmV0dXJuIOi9u-mHj-WGheW1jOWIhuW4g-W8j-WtmOWCqOihjOS4ulwiXG4gICAgICAgIC0tPiAoKilcbiAgICBlbHNlXG4gICAgICAgIC0-W2ZhbHNlXSBcInJldHVybiDpu5jorqTlpJbnva7mlbDmja7lrZjlgqjooYzkuLpcIlxuICAgICAgICAtLT4gKCopXG5cdFx0ZW5kaWZcbiBlbmRpZlxuZW5kaWZcblxuQGVuZHVtbCIsInR5cGUiOiJwdW1sIiwibWFyZ2luIjp0cnVlLCJpZCI6IkNNN1VDIiwidXJsIjoiaHR0cHM6Ly9jZG4ubmxhcmsuY29tL3l1cXVlL19fcHVtbC8xZmQ2NTZiYTNiMzlmZTVkZThmZWE3OGVmZGY5OGRkMS5zdmciLCJjYXJkIjoiZGlhZ3JhbSJ9",alt:null})),(0,o.kt)("a",{name:"9UAXN"}),(0,o.kt)("h3",{id:"new-features-related-operation-and-maintenance-operations"},"New features related operation and maintenance operations"),(0,o.kt)("p",null,"Directly query the data stored in each node's derby"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"GET /nacos/v1/cs/ops/derby?sql=select * from config_info\n\nreturn List<Map<String, Object>>\n")),(0,o.kt)("a",{name:"YcqO2"}),(0,o.kt)("h3",{id:"insufficient"},"insufficient"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Build a distributed data operation synchronization layer on the upper layer of the database, there are restrictions on the operation of the database, such as the first insert operation, then the select operation, and finally the update operation, which is interspersed with query statements in the data modification statement The order of operations is not supported"),(0,o.kt)("li",{parentName:"ol"},"Limiting the performance of the database, due to the indirect adjustment of the database transaction isolation level to serialization, the concurrency ability is artificially reduced")),(0,o.kt)("a",{name:"7dul8"}),(0,o.kt)("h3",{id:"future-evolution"},"Future evolution"),(0,o.kt)("p",null,"Apache Derby official will try to realize the synchronous replication operation of BingLog based on Raft, and realize the database synchronization capability from the bottom"))}m.isMDXComponent=!0}}]);