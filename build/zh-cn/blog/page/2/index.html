<!doctype html>
<html lang="zh-CN" dir="ltr" class="blog-wrapper blog-list-page plugin-blog plugin-id-default" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.4.3">
<title data-rh="true">Blog | Nacos</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://nacos.io/zh-cn/img/nacos_colorful.png"><meta data-rh="true" name="twitter:image" content="https://nacos.io/zh-cn/img/nacos_colorful.png"><meta data-rh="true" property="og:url" content="https://nacos.io/zh-cn/blog/page/2"><meta data-rh="true" name="docusaurus_locale" content="zh-cn"><meta data-rh="true" name="docsearch:language" content="zh-cn"><meta data-rh="true" name="keywords" content="Nacos"><meta data-rh="true" property="og:title" content="Blog | Nacos"><meta data-rh="true" name="description" content="Blog"><meta data-rh="true" property="og:description" content="Blog"><meta data-rh="true" name="docusaurus_tag" content="blog_posts_list"><meta data-rh="true" name="docsearch:docusaurus_tag" content="blog_posts_list"><link data-rh="true" rel="icon" href="https://img.alicdn.com/tfs/TB1hgJpHAPoK1RjSZKbXXX1IXXa-64-64.png"><link data-rh="true" rel="canonical" href="https://nacos.io/zh-cn/blog/page/2"><link data-rh="true" rel="alternate" href="https://nacos.io/en/blog/page/2" hreflang="en-US"><link data-rh="true" rel="alternate" href="https://nacos.io/zh-cn/blog/page/2" hreflang="zh-CN"><link data-rh="true" rel="alternate" href="https://nacos.io/blog/page/2" hreflang="default"><link data-rh="true" rel="alternate" href="https://nacos.io/blog/page/2" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/zh-cn/blog/rss.xml" title="Nacos RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/zh-cn/blog/atom.xml" title="Nacos Atom Feed">




<link rel="stylesheet" href="//g.alicdn.com/mamba/assets/0.0.19/mse-arc-ui.min.css">
<script src="//g.alicdn.com/mamba/assets/0.0.19/mse-arc-ui.min.js"></script>
<script src="//g.alicdn.com/alilog/mlog/aplus_v2.js" id="beacon-aplus" exparams="clog=o&amp;aplus&amp;sidx=aplusSidx&amp;ckx=aplusCkx"></script>
<script src="//g.alicdn.com/aes/??tracker/1.0.34/index.js,tracker-plugin-pv/2.4.5/index.js,tracker-plugin-event/1.2.5/index.js,tracker-plugin-jserror/1.0.13/index.js,tracker-plugin-api/1.1.14/index.js,tracker-plugin-perf/1.1.8/index.js,tracker-plugin-eventTiming/1.0.4/index.js"></script>
<script src="https://www.googletagmanager.com/gtag/js?id=G-YHS75WKFBR" async></script><link rel="stylesheet" href="/zh-cn/assets/css/styles.45670f1e.css">
<link rel="preload" href="/zh-cn/assets/js/runtime~main.799a6c4f.js" as="script">
<link rel="preload" href="/zh-cn/assets/js/main.99abaf7c.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}return t}()||function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="跳到主要内容"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">跳到主要内容</a></div><nav aria-label="主导航" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="切换导航栏" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/zh-cn/"><div class="navbar__logo"><img src="/zh-cn/img/nacos_colorful.png" alt="Nacos Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/zh-cn/img/nacos_colorful.png" alt="Nacos Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate"></b></a></div><div class="navbar__items navbar__items--right"><a class="navbar__item navbar__link" href="/zh-cn/">首页</a><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a class="navbar__link" aria-haspopup="true" aria-expanded="false" role="button" docid="/what-is-nacos" href="/zh-cn/docs/v2/what-is-nacos">2.X（推荐）</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/zh-cn/docs/next/v2/what-is-nacos">用户文档</a></li><li><a class="dropdown__link" href="/zh-cn/docs/v2/what-is-nacos">2.X（推荐）</a></li><li><a class="dropdown__link" href="/zh-cn/docs/1.X/v2/what-is-nacos">1.X</a></li></ul></div><a href="https://cn.aliyun.com/product/aliware/mse?spm=nacos-website.topbar.0.0.0" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">企业版NACOS<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><a href="https://developer.aliyun.com/ebook/36?spm=a2c6h.20345107.ebook-index.18.152c2984fsi5ST" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">NACOS架构与原理<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/zh-cn/blog">博客</a><a class="navbar__item navbar__link" href="/zh-cn/community">社区</a><a href="http://console.nacos.io/nacos/index.html" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">控制台样例<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link"><svg viewBox="0 0 24 24" width="20" height="20" aria-hidden="true" class="iconLanguage_DSK9"><path fill="currentColor" d="M12.87 15.07l-2.54-2.51.03-.03c1.74-1.94 2.98-4.17 3.71-6.53H17V4h-7V2H8v2H1v1.99h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11.76-2.04zM18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2l-4.5-12zm-2.62 7l1.62-4.33L19.12 17h-3.24z"></path></svg>中</a><ul class="dropdown__menu"><li><a href="/en/blog/page/2" target="_self" rel="noopener noreferrer" class="dropdown__link" lang="en-US">En</a></li><li><a href="/zh-cn/blog/page/2" target="_self" rel="noopener noreferrer" class="dropdown__link dropdown__link--active" lang="zh-CN">中</a></li></ul></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="最近博文导航"><div class="sidebarItemTitle_pO2u margin-bottom--md">所有文章</div><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/1.4.0-release">双十一购物节，Nacos 1.4.0 + Go SDK 1.0.1发布</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/2.0.1-release">Nacos 2.0.1 + 1.4.2 Release</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/2.0.3-release">Nacos 2.0.3版本发布，继续提升集群稳定性及升级稳定性</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/2.1.0-release">Nacos 2.1.0版本发布，支持鉴权及加解密插件</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/2.1.1-release">Nacos 四周年，2.1.1 及 1.4.4 版本同时发布</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/2.2.0-release">Nacos 2.2.0 版本发布，新增多种插件支持</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/2.2.1-release">Nacos 多个新版本发布，rust-sdk完全适配完成</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/2.2.2-release">Nacos 2.2.2发布，优化启动体验和鉴权提示</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/212-and-220beta-release">Nacos 2.1.2、2.2.0-BETA及go-sdk 2.1.1 版本同时发布，多语言生态再添大将</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/5w1h-what">Nacos 帮我们解决什么问题？—— 配置管理篇</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/5w1h-where">Nacos 有哪些典型的应用场景？—— 配置管理篇</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/access control design">Nacos权限控制设计方案</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/address-server">Nacos环境隔离</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/alibaba-configserver">阿里巴巴服务注册中心产品ConfigServer 10年技术发展回顾</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/announcement-token-secret-key">关于Nacos默认token.secret.key及server.identity风险说明及解决方案公告</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/apisix">Apache APISIX 基于 Nacos 实现服务发现</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/chengdu-dubbo">Nacos 计划发布v0.2版本，进一步融合Dubbo和SpringCloud生态</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/cmdb">Nacos打通CMDB实现就近访问</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/cncf">Nacos 进入CNCF landscape</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/consul-k8s">Consul与kubernetes整合公告[翻译]</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/csharp-0.5.0">Nacos-sdk-csharp 0.5.0正式发布，功能与Java版本对齐！</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/discovery-console">Nacos服务发现控制台预览</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/dns-sd">微服务架构中基于DNS的服务注册与发现</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/download">下载页</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/dynamic-route-zuul-nacos">使用Nacos实现Spring Cloud Zuul的动态路由</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/eureka2">Eureka 2.0 开源工作宣告停止？别担心，ANS 即将 C位强势出道！</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/feeling-of-ASoC-2019">参与开源，Offer拿到手软 -- 来自一名2019阿里巴巴编程之夏同学的亲述</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/huya-nacos">虎牙直播共建Nacos生态</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/huya-practice">虎牙直播在微服务改造方面的实践和总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/iscas2021">Nacos 开源之夏2021活动 报名正式开启</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/iscas2022">Nacos开源之夏2022，贡献社区赢取12000奖金</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/iscas2023">Nacos开源之夏2023，贡献社区赢取12000奖金</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/nacos 1.1.0">Nacos 1.1.0发布，支持灰度配置和地址服务器模式</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/nacos 1.1.4">Nacos 1.1.4发布，业界率先支持Istio MCP协议</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/nacos 1.2.0 guide">Nacos 1.2.0 权限控制介绍和使用</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/nacos-1.3.0-design">Nacos 1.3.0 全新内核构建过程</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/nacos-2nd-anniversary">Nacos 两周年献礼，Nacos 1.3.2 + Go SDK 1.0.0发布</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/nacos-confd">nacos-confd</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/nacos-distro-mechanism">Nacos 的 Distro 一致性协议</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/nacos-is-coming">支持Dubbo生态发展，阿里巴巴启动新的开源项目 Nacos</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/nacos-reigster-mechanism">Nacos 的一条注册请求会经历什么？</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/nacos-roadmap">Nacos Roadmap：Nacos GA后会有哪些大动作？</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/nacos">Nacos 0.1.0 版本Review 活动设计</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/nacos0.5">Nacos0.5发布，支持DNS-based Service Discovery，JAVA 11</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/nacos0.6">Nacos 0.6版本发布，支持Dubbo生态并且支持Docker部署</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/nacos0.8">Nacos 0.8.0版本进行发布</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/nacos0.9-intro">Nacos 0.9.0版本进行发布</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/nacos0.9.0">Nacos 0.9.0版本进行发布</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/nacos1.0.0">Nacos 发布 1.0.0 版本，可大规模投入到生产环境中</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/nacos3.0-is-coming">我们总结了3大使用建议，并首次公开 Nacos3.0 规划图 | Nacos 开源4周年</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/namespace-endpoint-best-practices">Namespace,endpoint 最佳实践</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/performance-compare">Nacos 2.0 升级前后性能对比压测</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/pilot mcp">Pilot MCP协议介绍</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/springboot-0.2.10">Nacos-spring-boot0.2.10发布，全面支持Nacos2.0</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/up-to-2w-star">双十一献礼 | Nacos Star破两万的回顾与展望</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/use-nacos-with-rainbond">在 Rainbond 中一键安装高可用 Nacos 集群</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/xiaomi-scale">小米Nacos2.0扩缩容最佳实践</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/higress">Higress + Nacos 微服务网关最佳实践</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/2021/08/01/mdx-blog-post">mdx-blog-post</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/2019/05/29/long-blog-post">long-blog-post</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/2019/05/28/first-blog-post">first-blog-post</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="http://schema.org/Blog"><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><meta itemprop="description" content="Nacos 配置管理有哪些典型的应用场景？"><meta itemprop="keywords" content="nacos"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/zh-cn/blog/5w1h-where">Nacos 有哪些典型的应用场景？—— 配置管理篇</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2023-10-10T11:47:41.000Z" itemprop="datePublished">2023年10月10日</time> · <!-- -->阅读需 16 分钟</div></header><div class="markdown" itemprop="articleBody"><blockquote><p>Authors: 何煦</p></blockquote><p><a href="/zh-cn/blog/5w1h-what">上篇</a>作为 Nacos 5W1H 系列文章的开篇，从“What” 讲述了 Nacos 配置管理能帮我们解决的问题：以简单、优雅、高效的方式管理配置，实现配置的动态变更，大大降低运维成本。</p><p>本文将围绕“Where”，讲述 Nacos 配置管理的三个典型的应用场景：</p><ul><li>数据库连接信息</li><li>限流阈值和降级开关</li><li>流量的动态调度</li></ul><h1>数据库连接信息</h1><p>曾经有朋友跟我聊过一个问题，“业务飞速发展，团队越来越大，人员流动也相对频繁起来，怎么才能更好的保证数据的安全性，不被泄露呢？”。他提到这样一个场景，公司创立初期，服务后端的代码都是他一行一行码出来的，当时只有他一个人，后端与数据库的连接配置信息也就直接放置在项目的配置文件中。他使用的是 Spring Boot 框架，配置信息就是存放在 <code>application.properties</code> 中，使用 Spring 的 profile 属性保证不同环境连接不同的数据库。如下所示：</p><p>生产环境：application-prod.properties</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">spring.datasource.url=生产环境的数据库连接地址</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">spring.datasource.username=生产环境的数据库用户账号</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">spring.datasource.password=生产环境的数据库用户密码</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>开发环境：application-dev.properties</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">spring.datasource.url=开发环境的数据库连接地址</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">spring.datasource.username=开发环境的数据库用户账号</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">spring.datasource.password=开发环境的数据库用户密码</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>测试、预发环境也是类似。这种将数据库连接信息直接放置在配置文件中，跟着项目代码一起通过 Git 管理，的确是有蛮大的数据泄露的风险。试想，一个新来不久的小伙伴，他一当要投入研发工作，有 Git Pull 代码的权限之后，代表他可能就拥有了直接操作线上数据库的权限了。当时的我给他建议可以通过以下几个方面去降低数据风险：</p><ul><li>将数据库连接信息等敏感配置从项目中剥离；</li><li>数据库增加 IP 白名单连接限制；</li><li>最小权限原则：每个账号只配置所必需的权限，避免删表删库等高危操作；</li><li>定期修改数据库账号、密码。</li></ul><p>回想起来，我当时给的建议并没有完全解决他的问题，甚至还带来了其他一些问题。例如，上述的第一点，“将敏感配置从项目剥离”，剥离出来的敏感配置存放到哪里？怎么管理这些配置呢？也许，你会想到，存放到应用部署机器的环境变量或某个文件中。不，一样有风险，说不定哪天开发同学必须得登录上机器排查问题，就有泄露的风险，总之，得尽可能地做到在整个开发流程都不会有任何泄露的风险。应用中可能不只是连接一个数据源，分库分表的情况，不同数据存储（如 MySQL / Redis / Elasticsearch 等）的情况，还有，其他更多敏感配置项，配置数据的增多会给管理带来不便。</p><p>另外，“定期修改数据库账号、密码”，修改后我能怎么方便快捷的下发到所有应用程序中呢？既然是敏感配置，其变更也会带来不少的风险，我需要能先到小量的几台机器验证，保证对业务无影响，我再全部下发到其他所有的机器上去，是否还得有“灰度发布”的功能呢？账号密码修改下发后，应用出现异常，影响到业务了，我要怎么快速地回滚呢？是否还得有“版本控制”、“快速回滚”的功能呢？不是所有的开发同学都有权限能修改敏感配置信息，是否还需要有“权限管控”的功能？对敏感配置的任何操作都应该被记录，是否还需要有“变更审计”的功能呢？</p><p>现在，我有了更好的建议：使用 Nacos 配置管理模块，将敏感配置信息都存放到 Nacos 中。Nacos 配置管理，其中一个立身之本就是为敏感配置保驾护航。它提供上述场景所需的功能，通过命名空间区分不同环境（开发、测试、预发、生产），通过“版本控制”保证变更可追溯，通过“快速回滚”保证错误变更时影响最小，通过的“灰度发布”功能保障配置安全平稳地变更，还有更多更全面功能（权限管控、变更审计等）即将支持。</p><p>那么，怎么将敏感配置项目的配置文件中迁移到 Nacos 中呢？下面以 Spring Boot 连接 MySQL 为例：</p><ol><li>添加依赖</li></ol><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">&lt;dependency&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;groupId&gt;com.alibaba.boot&lt;/groupId&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;artifactId&gt;nacos-config-spring-boot-starter&lt;/artifactId&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;version&gt;${latest.version}&lt;/version&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;/dependency&gt;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>注意 Spring Boot 1.x 使用 <code>nacos-config-spring-boot-starter</code> 0.1.x 版本，Spring Boot 2.x 使用 <code>nacos-config-spring-boot-starter</code> 0.2.x 版本。</p><ol start="2"><li>在 <code>application.properties</code> 中添加 Nacos 连接配置</li></ol><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">nacos.config.server-addr=127.0.0.1:8848</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这里是简单的示例，在实际生产中，还需配置 Nacos 命名空间信息（区分环境）、鉴权信息（如 AccessKey、SecretKey 等，即将支持的权限访问控制）。而 Nacos 配置模块对应的阿里云产品 ACM，借助于 <a href="https://help.aliyun.com/document_detail/72013.html" target="_blank" rel="noopener noreferrer">ECS 实例 RAM 角色</a>，最终能到达连 AccessKey、SecretKey 都不需要填写的目的。</p><ol start="3"><li>添加 <code>@NacosPropertySource</code> 注解</li></ol><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">@SpringBootApplication</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@NacosPropertySource(dataId = &quot;mysql.properties&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class SpringBootMySQLApplication {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        SpringApplication.run(Application.class, args);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol start="4"><li>在本地启动的 Nacos 控制台上新增 dataId 为 <code>mysql.properties</code> 的配置，配置内容为 MySQL 连接配置信息：</li></ol><p><img loading="lazy" src="https://cdn.nlark.com/lark/0/2018/png/96000/1543757963981-1a8a4a20-bb01-4b06-a17d-4bd27bb278b5.png" alt="image.png | left | 747x447" class="img_ev3q"></p><p>通过这四个简单的步骤，就将 MySQL 连接信息从原来的 <code>application.properties</code> 迁移到 Nacos 的，让 Nacos 将敏感配置管控起来，大大降低数据泄露的风险。同时，Nacos 配置管理提供的“统一管控”、“版本控制”、“快速回滚”等强大的功能也为其运维管理带来极大的便利。</p><p>完整示例代码请参看：<a href="https://github.com/nacos-group/nacos-examples/tree/master/nacos-spring-boot-example/nacos-spring-boot-config-mysql-example" target="_blank" rel="noopener noreferrer">https://github.com/nacos-group/nacos-examples/tree/master/nacos-spring-boot-example/nacos-spring-boot-config-mysql-example</a></p><h1>限流阈值和降级开关</h1><p>限流、降级，众所周知，是在开发高并发系统过程中需要考虑的两大关键点，是运行时保护系统的两大利器。限流阈值和降级开关，最终是抽象为一个个的配置项，要想实现运行时的动态调整阈值和开关的启停，将这些配置项存放到 Nacos 的配置模块中最适合不过了。</p><p>在今年 8 月的时候，阿里巴巴开源了 Sentinel，以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。在阿里巴巴内部，Nacos 跟 Sentinel 就是多年携手相伴，砥砺前行的好机油，为双 11 等各种大促立下了功劳，也为剁手党提供了良好的购物体验。</p><p>下面就以 Sentinel 流控为例，演示如果通过 Nacos 来做到运行时的动态控制流量：</p><ol><li>添加依赖</li></ol><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">&lt;dependency&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;artifactId&gt;sentinel-core&lt;/artifactId&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;version&gt;${latest.version}&lt;/version&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;/dependency&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;dependency&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;artifactId&gt;sentinel-datasource-extension&lt;/artifactId&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;version&gt;${latest.version}&lt;/version&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;/dependency&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;dependency&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;artifactId&gt;sentinel-datasource-nacos&lt;/artifactId&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;version&gt;${latest.version}&lt;/version&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;/dependency&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;dependency&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;version&gt;${latest.version}&lt;/version&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;/dependency&gt;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol start="2"><li>模拟并发请求</li></ol><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">final class RunTask implements Runnable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while (!stop) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Entry entry = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                entry = SphU.entry(resourceName);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // token acquired, means pass</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                pass.addAndGet(1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } catch (BlockException e1) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                block.incrementAndGet();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } catch (Exception e2) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // biz exception</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                total.incrementAndGet();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (entry != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    entry.exit();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Random random2 = new Random();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                TimeUnit.MILLISECONDS.sleep(random2.nextInt(50));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } catch (InterruptedException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // ignore</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol start="3"><li>配置 Nacos 连接信息与 dataId 等，并将其设置为 Sentinel 的数据源</li></ol><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class NacosDynamicFlowDemo {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final String KEY = &quot;TestResource&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        final String remoteAddress = &quot;localhost&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        final String groupId = &quot;DEFAULT_GROUP&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        final String dataId = &quot;com.alibaba.nacos.demo.flow.rule&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ReadableDataSource&lt;String, List&lt;FlowRule&gt;&gt; flowRuleDataSource = new NacosDataSource&lt;&gt;(remoteAddress, groupId, dataId,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            source -&gt; JSON.parseObject(source, new TypeReference&lt;List&lt;FlowRule&gt;&gt;() {}));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        FlowRuleManager.register2Property(flowRuleDataSource.getProperty());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Assume we config: resource is `TestResource`, initial QPS threshold is 5.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        FlowQpsRunner runner = new FlowQpsRunner(KEY, 1, 10000);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        runner.simulateTraffic();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        runner.tick();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol start="4"><li>在本地启动的 Nacos 控制台中新建 dataId 为 <code>com.alibaba.nacos.demo.flow.rule</code> 的流控配置</li></ol><p><img loading="lazy" src="https://cdn.nlark.com/lark/0/2018/png/96000/1543757996381-9b766bd9-d400-4426-8c65-eb5d17fce5db.png" alt="image.png | left | 747x580" class="img_ev3q"></p><ol start="5"><li>运行 <code>NacosDynamicFlowDemo</code>，你会看到如下标准输出信息</li></ol><p><img loading="lazy" src="https://cdn.nlark.com/lark/0/2018/png/96000/1543758470779-0a01e695-0ef9-4186-b737-190310eaf457.png" alt="image.png | left | 588x222" class="img_ev3q"></p><ol start="6"><li>再到 Nacos 控制台修改刚刚新建的流控配置，将限流阈值 <code>count</code> 的值修改为 <code>1.0</code>，完整的标准输出信息如下</li></ol><p><img loading="lazy" src="https://cdn.nlark.com/lark/0/2018/png/96000/1543758536357-bdf7733b-aafc-482b-b0c7-27917434e643.png" alt="image.png | left | 592x392" class="img_ev3q"></p><p>以上示例演示了如何通过 Nacos + Sentinel 实现动态流量控制的能力，核心就是用到了 Nacos 配置模块“动态推送”的能力。原理是 <code>sentinel-datasource-nacos</code> 集成了 <code>nacos-client</code> ，其与 <code>nacos-server</code> 维持着连接，当用户在 Nacos 控制台进行配置变更时，<code>nacos-server</code> 会快速地将该配置的最新内容推送到 <code>nacos-client</code> 中，Sentinel 一拿到最新的流控配置，就转换了流控策略，如示例将流控阈值调整为 1.0，限制为更少的流量进入系统的业务处理流程。</p><p>完整示例代码请参看：<a href="https://github.com/nacos-group/nacos-examples/tree/master/nacos-sentinel-example" target="_blank" rel="noopener noreferrer">https://github.com/nacos-group/nacos-examples/tree/master/nacos-sentinel-example</a></p><h1>流量的动态调度</h1><p>业务发展壮大到一定的规模，单一的集群已经承载不了全部的用户请求，需要将用户的流量分流到不同的集群上。当然，更进一步的方案是：不同的集群位于不同的区域，这样，除了缓解业务处理的压力，也给系统带来容灾的能力。</p><p>比如，某电商系统有 1 亿用户量，将系统的流量按照用户的 ID 进行切分，ID 为 1-1000W 的用户请求分发到区域 A 的集群 a 上，ID 为 10001W-2000W 的用户请求流量分发到区域 B 的集群 b 上，以此类推，最终将所有用户的请求流量打散到 10 个不同区域的集群上，同时，每个集群冗余了一些系统资源。当区域 A 的机房发生不可抗的灾难（如地震）时，我们需要有动态调度流量的能力，最好能秒级得将流量从区域 A 调度到另外可用的区域的集群上。</p><p>这正是 Nacos 配置管理大有作为的地方，将用户 ID 的分片和对应的路由规则存放在 Nacos 的中，配合统一接入层等的组件，就能将流量打散到各个集群上，进而让系统能承载更大的流量，以更好的支撑业务的发展。另外，将其存放与 Nacos 中，也就具备了配置“动态化”的能力，一旦某区域出现基础设施无法及时恢复的问题时，只需在 Nacos 的控制台上修改 ID 分片的路由规则，就能将有问题的区域流量快速切换到其他可用的区域上，保障对业务几乎无损。Nacos 在阿里内部能做到秒级推送到十万级别机器上的推送效率。</p><h1>总结</h1><p>本文为 Nacos 5W1H 系列文章的第二篇，围绕“Where”，讲述了 Nacos 配置管理的几个典型的应用场景：数据库连接信息、限流阈值和降级开关、流量的动态调度。其实还有更多更大胆的应用场景，如“大数据实时计算算法调整”、“异地容灾多活”、“应用业务场景动态推送”等等，可以参看 <a href="https://help.aliyun.com/document_detail/59972.html" target="_blank" rel="noopener noreferrer">Nacos 的阿里云产品 ACM 的使用场景</a> 。Nacos 配置管理模块，将敏感配置收拢管控起来，极大降低数据泄露等风险，并且提供如“动态推送”、“版本控制”、“快速回滚”等功能，保障了敏感配置的变更安全平稳的执行。</p><p>在限流与降级的场景，通过一个示例，为大家演示了如何通过 Nacos + Sentinel 实现流量的动态控制，这也是 Nacos 配置管理的一个十分典型的应用场景。降级也一样，大促高峰期间将某个非关键的系统组件进行关闭，在过了高峰期后再开启，这个也是可以通过 Nacos 的“动态推送”的功能来实现。</p><p>总之，只要系统涉及到了“敏感的配置”、“动态的配置”，都应该考虑将配置放入到 Nacos 中，让 Nacos 管控起来。</p><p><img loading="lazy" src="https://cdn.nlark.com/lark/0/2018/png/15914/1543892400157-f9dbf212-c835-44be-871c-73166b3b177b.png" alt="屏幕快照 2018-12-03 18.59.52.png | left" class="img_ev3q"></p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><meta itemprop="description" content="Nacos自开源以来，权限控制一直需求比较强烈，这也反应了用户需求将Nacos部署到生产环境的需求。Nacos 1.2.0版本将会支持服务发现和配置管理的权限控制，保障用户安全上生产。本文主要介绍Nacos权限控制的设计方案，当然这个方案在1.2.0发布前可能会有少许调整，同时也欢迎广大用户对该方案提出自己的建议。"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/zh-cn/blog/access control design">Nacos权限控制设计方案</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2023-10-10T11:47:41.000Z" itemprop="datePublished">2023年10月10日</time> · <!-- -->阅读需 13 分钟</div></header><div class="markdown" itemprop="articleBody"><a name="oBGKT"></a># 方案背景 Nacos自开源以来，权限控制一直需求比较强烈，这也反应了用户需求将Nacos部署到生产环境的需求。Nacos 1.2.0版本将会支持服务发现和配置管理的权限控制，保障用户安全上生产。本文主要介绍Nacos权限控制的设计方案，当然这个方案在1.2.0发布前可能会有少许调整，同时也欢迎广大用户对该方案提出自己的建议。<a name="FKbJ4"></a>## 什么是权限控制？ 在分布式服务调用时，需要对未知的或者不受信任的请求来源的请求进行识别和拒绝。权限控制一般分为两个阶段：身份识别（Authentication）和权限识别（Authorization）。身份认证主要确定访问者的身份，权限识别则判断这个访问者是否有对应资源的权限。<br><br>在Nacos的场景中，配置管理的权限控制指的是设置某个配置能否被某个用户读写，这个比较好理解，没有权限的用户旧无法读取或者写入对应的配置。服务发现的权限控制指的是用户是否有权限进行某个服务的注册或者订阅，这里需要注意的是服务发现的权限控制只能够控制用户是否可以从Nacos获取到服务的地址或者在Nacos上修改服务的地址。但是如果已经获取到了服务的地址，Nacos无法在服务真正调用时进行权限控制，这个时候的权限控制需要由服务框架来完成。<p><img loading="lazy" src="https://cdn.nlark.com/yuque/0/2019/png/333810/1576216016307-2da56934-917f-46ec-b3eb-a221bc91a9e0.png#align=left&amp;display=inline&amp;height=240&amp;name=image.png&amp;originHeight=480&amp;originWidth=1904&amp;size=271408&amp;status=done&amp;style=none&amp;width=952" alt="image.png" class="img_ev3q"></p><a name="iiXvl"></a>## 常见实现方式<a name="SzK17"></a>### 认证（Authentication）<ul><li>用户名+密码</li><li>Cookie（只适用于浏览器）</li><li>Session</li><li>Token（JWT，Oauth，LDAP，SAML，OpenID）</li><li>AK/SK<a name="3szY3"></a></li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="鉴权authorization">鉴权（Authorization）<a href="#鉴权authorization" class="hash-link" aria-label="鉴权（Authorization）的直接链接" title="鉴权（Authorization）的直接链接">​</a></h3><ul><li>ACL： 规定<strong>资源</strong>可以被哪些<strong>主体</strong>进行哪些操作；</li><li>DAC： 规定<strong>资源</strong>可以被哪些<strong>主体</strong>进行哪些操作 同时，<strong>主体</strong>可以将<strong>资源</strong>的权限，授予其他<strong>主体</strong>；</li><li>MAC：a. 规定<strong>资源</strong>可以被哪些类别的<strong>主体</strong>进行哪些<strong>操作</strong> b. 规定<strong>主体</strong>可以对哪些等级的<strong>资源</strong>进行哪些<strong>操作</strong> 当一个<strong>操作</strong>，同时满足a与b时，允许<strong>操作</strong>；</li><li>RBAC： a. 规定<strong>角色</strong>可以对哪些<strong>资源</strong>进行哪些<strong>操作</strong> b. 规定<strong>主体</strong>拥有哪些<strong>角色</strong>当一个操作，同时满足a与b时，允许<strong>操作</strong>；</li><li>ABAC： 规定哪些<strong>属性</strong>的<strong>主体</strong>可以对哪些<strong>属性</strong>的<strong>资源</strong>在哪些<strong>属性</strong>的情况下进行哪些<strong>操作</strong>。<a name="0FxEV"></a></li></ul><h2></h2><a name="0YQ9P"></a>## 常见注册中心和配置中心的实现方式<a name="5yePW"></a>### Zookeeper Zookeeper主要使用的是ACL的方式，直接将资源授权给对应的实体。一条授权记录主要由以下部分组成：<ul><li><path></path>: 设置权限的路径</li><li>&lt;acl_type&gt;: ACL鉴权类型，分为world，ip，auth，digest</li><li>&lt;acl_content&gt;: ACL鉴权内容，与鉴权类型关联</li><li><action></action>: CREATE，DELETE，READ，WRITE，ADMIN</li></ul><p>操作示例：</p><div class="language-xml codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-xml codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$ setAcl </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">path</span><span class="token tag" style="color:#00009f"> </span><span class="token tag punctuation" style="color:#393A34">/&gt;</span><span class="token plain"> </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">acl_type</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain">:</span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">acl_content</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain">:</span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">action</span><span class="token tag" style="color:#00009f"> </span><span class="token tag punctuation" style="color:#393A34">/&gt;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$ setAcl /xxx/yyy world:anyone:cdrwa</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$ setAcl /xxx/yyy ip:1.1.1.1:cdrwa</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$ addauth digest root:pa55wdsetAcl /xxx/yyy auth:root:cdrwa</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><a name="GI6TE"></a>### Consul Consul的鉴权也是偏向于ACL机制，主要分为三个部分：<ul><li>Rule：定义对某个资源的权限</li><li>Policy：将一系列Rule组合成一个Policy</li><li>Token：为某个Token分配一个或多个Policy，API带上Token进行鉴权</li></ul><p><img loading="lazy" src="https://cdn.nlark.com/yuque/0/2019/png/333810/1576218881317-bb025c9f-f6ad-4df1-9f7f-f116e8d95671.png#align=left&amp;display=inline&amp;height=240&amp;name=image.png&amp;originHeight=273&amp;originWidth=848&amp;size=49225&amp;status=done&amp;style=none&amp;width=746" alt="image.png" class="img_ev3q"></p><a name="oLlfm"></a>### Eureka Eureka使用的鉴权是基于Spring Security实现的，支持用户名和密码的访问控制，一个简单的例子如下：<br><div class="language-yaml codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-yaml codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token key atrule" style="color:#00a4db">spring</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token key atrule" style="color:#00a4db">security</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token comment" style="color:#999988;font-style:italic"># 开启认证，Spring Cloud2.0后添加jar会自动集成并开启</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token comment" style="color:#999988;font-style:italic">#</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token key atrule" style="color:#00a4db">basic.enabled</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> </span><span class="token boolean important" style="color:#36acaa">true</span><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token comment" style="color:#999988;font-style:italic"># 用户名密码</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token key atrule" style="color:#00a4db">user</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token key atrule" style="color:#00a4db">name</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> test </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token key atrule" style="color:#00a4db">password</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> test</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><a name="qrC17"></a>### Apollo 基于RBAC的权限控制，可以在命名空间级别进行资源的授权：<br>![image.png](https://cdn.nlark.com/yuque/0/2019/png/333810/1576218970350-01402621-0a13-4102-a590-20c6cefe4918.png#align=left&amp;display=inline&amp;height=118&amp;name=image.png&amp;originHeight=101&amp;originWidth=640&amp;size=21453&amp;status=done&amp;style=none&amp;width=746)<a name="zH1U3"></a># 方案详情 Nacos的权限控制，目标是能够满足用户基本的鉴权需求，同时能够保持扩展性，可以支持去对接用户自带的用户管理系统或者鉴权系统，包括后面和K8S生态以及Service Mesh生态能够无缝的融合。基于这样的考虑，目前Nacos权限控制的设计是自带一个基本的实现，然后可以支持用户扩展。具体的设计如下。<a name="pd2aV"></a>## 模块设计 整体的模块设计是尽量将鉴权的逻辑抽象出来，不在服务发现模块或者配置管理模块添加相关的逻辑。通过配置文件可以选择当前使用的鉴权系统。Nacos自带的认证系统使用JWT Token，自带的鉴权系统使用的是RBAC。<p><img loading="lazy" src="https://cdn.nlark.com/yuque/0/2019/png/333810/1576219027093-45345003-c583-46ec-a161-01b5f4b3ff47.png#align=left&amp;display=inline&amp;height=450&amp;name=image.png&amp;originHeight=900&amp;originWidth=1744&amp;size=699757&amp;status=done&amp;style=none&amp;width=872" alt="image.png" class="img_ev3q"></p><a name="vr4PO"></a>## 认证算法 对于用户来说，不管是在控制台还是在客户端，都是上传用户名和密码来获取一个token，然后后续的每一次到Nacos的请求都会带上这个token来表明身份。这个token会有一个失效时间，对于控制台来说，只需要直接提示用户重新登录即可，对于客户端则需要有一个定期到Nacos刷新token的逻辑。<p><img loading="lazy" src="https://cdn.nlark.com/yuque/0/2019/png/333810/1576219050917-51013ce2-49f3-4a86-b5f9-bd07fc88f8e8.png#align=left&amp;display=inline&amp;height=368&amp;name=image.png&amp;originHeight=736&amp;originWidth=1718&amp;size=575605&amp;status=done&amp;style=none&amp;width=859" alt="image.png" class="img_ev3q"></p><a name="9ncb7"></a>## 鉴权算法 Nacos自带的鉴权系统使用的是RBAC模型，可以在网上查询相关的资料。<a name="DjMVc"></a>### 数据模型 鉴权的数据模型也是基于标准的RBAC来设计的，分为用户、角色和权限三部分。用户就是由用户名和密码组成的用户信息，角色则是一个逻辑上的用户组，Nacos启动时会自带一个全局管理员的角色，只有这个全局管理员的角色可以进行添加用户、添加角色、添加授权等操作，保证安全性。而权限则是由资源+动作来组成。<p><img loading="lazy" src="https://cdn.nlark.com/yuque/0/2019/png/333810/1576736418792-936a9d1a-5095-47fc-9f87-230abed38384.png#align=left&amp;display=inline&amp;height=451&amp;name=image.png&amp;originHeight=902&amp;originWidth=1834&amp;size=438246&amp;status=done&amp;style=none&amp;width=917" alt="image.png" class="img_ev3q"></p><a name="gIPMW"></a>### 接口设计 以下接口涉及到登录和鉴权的所有逻辑，这些接口除了登录接口，其他接口都只能由全局管理员来调用。<a name="yA6U0"></a>#### 用户管理<ul><li>创建用户：POST
/nacos/v1/auth/users?username=xx&amp;password=yy</li><li>删除用户：DELETE /nacos/v1/auth/users?username=xx&amp;password=yy</li><li>更新用户：PUT /nacos/v1/auth/users?username=xx&amp;oldPassword=yy&amp;newPassword=zz</li><li>登录：POST
/nacos/v1/auth/users/login?username=xxx&amp;password=yyy</li></ul><a name="eHYVh"></a>#### 角色管理<ul><li>创建角色/绑定用户到角色：POST /nacos/v1/auth/roles?role=xx&amp;username=yy</li><li>删除某个用户的角色：DELETE /nacos/v1/auth/roles?role=xx&amp;username=yy</li><li>获取用户的所有角色：GET /nacos/v1/auth/roles?username=xxx</li></ul><a name="SRZQx"></a>#### 权限管理<ul><li>给角色添加权限：POST /nacos/v1/auth/permissions?role=xxx&amp;resource=yyy&amp;action=zzz</li><li>从角色删除权限：DELETE /nacos/v1/auth/permissions?role=xxx&amp;resource=yyy&amp;action=zzz</li><li>获取某个角色的权限：GET /nacos/v1/auth/permissions?role=xxx</li></ul><a name="Bb2oV"></a>## 页面交互 目前的设计方案可以支持最小到dataId级别的鉴权，但是粒度越细在页面的展示就会越复杂，需要每个资源都去检查是否有权限然后再决定是否展示，对于数据量比较大的情况，会非常影响服务端的性能。不过可以肯定的是一定会支持命名空间级别的读写授权，用户可以在页面配置将某个命名空间的读写权限授权给某一个角色，然后再将这个角色授权给某个用户。至于更细粒度的授权，可能考虑不支持或者在1.2.0之后的版本支持。<a name="PwF7l"></a>### 用户管理 ![image.png](https://cdn.nlark.com/yuque/0/2019/png/333810/1576225555266-ed32865d-95fb-4719-8d81-b25b55fbe711.png#align=left&amp;display=inline&amp;height=246&amp;name=image.png&amp;originHeight=370&amp;originWidth=1120&amp;size=137189&amp;status=done&amp;style=none&amp;width=746)<a name="vEW9w"></a>### 角色管理<p><img loading="lazy" src="https://cdn.nlark.com/yuque/0/2019/png/333810/1576225984713-8134d131-a3b5-4000-8093-d8a793c8b461.png#align=left&amp;display=inline&amp;height=255&amp;name=image.png&amp;originHeight=378&amp;originWidth=1106&amp;size=134468&amp;status=done&amp;style=none&amp;width=746" alt="image.png" class="img_ev3q"></p><a name="TwHTX"></a>### 权限管理<p><img loading="lazy" src="https://cdn.nlark.com/yuque/0/2019/png/333810/1576226004009-ca20d92d-889d-4926-a0d7-f613013d0f59.png#align=left&amp;display=inline&amp;height=249&amp;name=image.png&amp;originHeight=412&amp;originWidth=1232&amp;size=164158&amp;status=done&amp;style=none&amp;width=746" alt="image.png" class="img_ev3q"></p><a name="t34hG"></a>## 关键逻辑<ol><li>每个模块继承ResourceParser来实现各自模块的资源名解析器：</li></ol><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public interface ResourceParser {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 输入为请求信息，输出为一个资源名：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    String parseResource(Object request);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol start="2"><li>在每个需要鉴权的方法上添加一个注解，来指定这个方法对应的资源名，动作及资源解析器：</li></ol><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">@Secured(resource=“service1”,action=“read”, parser=NamingParser.class)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public void registerInstance() {…}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这个注解的介绍如下：</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">@Retention(RetentionPolicy.RUNTIME)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public @interface Secured {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 动作类型，默认为读类型，全部类型有CREAT|DELETE|READ|WRITE|ADMIN</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ActionTypes action() default ActionTypes.READ;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 资源名，可以显示指定资源名，如不指定，将由资源解析器解析出资源名</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    String resource() default &quot;&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 资源解析器，解析资源名，优先级比name()低</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Class&lt;? extends ResourceParser&gt; parser() default DefaultResourceParser.class;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol start="3"><li>在一个filter里进行登录和鉴权的逻辑，通过获取注解上的信息来拿到资源和动作，从request里获取到用户信息，然后进行鉴权。</li></ol><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 判断是否需要鉴权：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">if (method.isAnnotationPresent(Secured.class) &amp;&amp; authConfigs.isAuthEnabled()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Secured secured = method.getAnnotation(Secured.class);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 获取注解里配置的动作类型和资源名：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    String action = secured.action().toString();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    String resource = secured.resource();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 若资源名为空，进行资源解析：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (StringUtils.isBlank(resource)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ResourceParser parser = secured.parser().newInstance();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        resource = parser.parseResource(req);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (StringUtils.isBlank(resource)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 没有找到资源，则直接返回:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throw new AccessException(&quot;resource name invalid!&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 先调用login进行认证，再调用auth进行鉴权：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    authManager.auth(new Permission(resource, action), authManager.login(req));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol start="3"><li>鉴权接口抽象如下：</li></ol><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public interface AuthManager {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 根据请求进行用户认证，可以由用户进行扩展</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    User login(Object request) throws AccessException;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 根据用户信息和请求的权限，进行授权，也可以由用户进行扩展</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void auth(Permission permission, User user) throws AccessException;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol start="4"><li>Nacos自带的鉴权实现逻辑介绍如下：</li></ol><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class NacosAuthManager implements AuthManager {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public User login(Object request) throws AccessException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 从请求中获取用户信息，可以传入token，也可以传入用户名密码。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 1.传入用户名密码时，验证用户名密码，生成新的token放到User里；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 2.传入token时，验证token是否有效；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public void auth(Permission permission, User user) throws AccessException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 1.从用户信息中拿到角色信息</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 2.从角色信息中获取权限列表</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 3.匹配请求的权限是否在权限列表里</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><a name="q40cy"></a># 参考资料 【1】[https://zhuanlan.zhihu.com/p/70548562](https://zhuanlan.zhihu.com/p/70548562)<br>【2】[https://learn.hashicorp.com/consul/security-networking/production-acls](https://learn.hashicorp.com/consul/security-networking/production-acls)<br>【3】[https://zookeeper.apache.org/doc/r3.1.2/zookeeperProgrammers.html#sc_ZooKeeperAccessControl](https://zookeeper.apache.org/doc/r3.1.2/zookeeperProgrammers.html#sc_ZooKeeperAccessControl)</div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><meta itemprop="description" content="随着Nacos 0.8版本的release，Nacos离正式生产版本又近了一步（其实已经有不少企业已经上了生产，如虎牙）。一般而言，企业研发的流程一般是这样的：先在测试环境开发和测试功能，然后再灰度，最后发布到生产环境。并且，为了生产环境的稳定，测试环境需要跟生产环境隔离；必然要遇到一个问题：多环境问题，即多个环境的数据（如测试环境和生产环境）如何隔离？如何优雅的隔离（不需要用户做任何改动）。下文将就Nacos环境隔离问题，向大家介绍阿里在这方面的实践经验。"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/zh-cn/blog/address-server">Nacos环境隔离</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2023-10-10T11:47:41.000Z" itemprop="datePublished">2023年10月10日</time> · <!-- -->阅读需 10 分钟</div></header><div class="markdown" itemprop="articleBody"><p>随着Nacos 0.8版本的release，Nacos离正式生产版本又近了一步（其实已经有不少企业已经上了生产，如虎牙）。一般而言，企业研发的流程一般是这样的：先在测试环境开发和测试功能，然后再灰度，最后发布到生产环境。并且，为了生产环境的稳定，测试环境需要跟生产环境隔离；必然要遇到一个问题：多环境问题，即多个环境的数据（如测试环境和生产环境）如何隔离？如何优雅的隔离（不需要用户做任何改动）。下文将就Nacos环境隔离问题，向大家介绍阿里在这方面的实践经验。</p><a name="d0eabe32"></a><h2 class="anchor anchorWithStickyNavbar_LWe7" id="什么是环境">什么是环境？<a href="#什么是环境" class="hash-link" aria-label="什么是环境？的直接链接" title="什么是环境？的直接链接">​</a></h2><p>说到环境隔离，首先应该搞清楚什么环境。 环境这个词目前还没有一个比较统一的定义，有些公司叫环境，在阿里云上叫region，在kubernetes架构中叫namespace等等。本文认为，环境是逻辑上或物理上独立的一整套系统，这套系统中包含了处理用户请求的全部组件（网关、服务框架、微服务注册中心、配置中心、消息系统、缓存、数据库等），可以处理指定类别的请求。举个栗子，很多网站都会有用户id的概念，可以按照用户id划分，用户id以偶数结尾的请求全部由一套系统处理，而奇数结尾的请求由另一套系统处理。如下图所示。 我们这里说的环境隔离是指物理隔离，即不同环境是指不同的机器集群。</p><p><img loading="lazy" src="https://cdn.nlark.com/yuque/0/2019/png/333810/1559699207043-bff71a91-b187-489e-a3c4-79322913fd54.png#alt=undefined" class="img_ev3q"></p><a name="efec68f6"></a><h2 class="anchor anchorWithStickyNavbar_LWe7" id="环境隔离有什么用">环境隔离有什么用<a href="#环境隔离有什么用" class="hash-link" aria-label="环境隔离有什么用的直接链接" title="环境隔离有什么用的直接链接">​</a></h2><p>上一节定义了环境的概念，即一套包含了处理用户请求全部必要组件的系统，用来处理指定类别的请求。本节跟大家讨论一下环境隔离有哪些好处。从概念的定义可以看出，环境隔离至少有三个方面的好处：故障隔离、故障恢复、灰度测试；</p><a name="dbbde2aa"></a><h3 class="anchor anchorWithStickyNavbar_LWe7" id="故障隔离">故障隔离<a href="#故障隔离" class="hash-link" aria-label="故障隔离的直接链接" title="故障隔离的直接链接">​</a></h3><p>首先，因为环境是能够处理用户请求的独立组件单元，也就是说用户请求的处理链路有多长，都不会跳出指定的机器集群。即使这部分机器故障了，也只是会影响部分用户，从而把故障隔离在指定的范围内。如果我们按照用户id把全部机器分为十个环境，那么一个环境出问题，对用户的影响会降低为十分之一，大大提高系统可用性。</p><a name="e443c432"></a><h3 class="anchor anchorWithStickyNavbar_LWe7" id="故障恢复">故障恢复<a href="#故障恢复" class="hash-link" aria-label="故障恢复的直接链接" title="故障恢复的直接链接">​</a></h3><p>环境隔离的另一个重要优势是可以快速恢复故障。当某个环境的服务出现问题之后，可以快速通过下发配置，改变用户请求的路由方向，把请求路由到另一套环境，实现秒级故障恢复。当然，这需要一个强大的分布式系统支持，尤其是一个强大的配置中心（如Nacos），需要快速把路由规则配置数据推送到全网的应用进程。</p><a name="385e0b0a"></a><h3 class="anchor anchorWithStickyNavbar_LWe7" id="灰度测试">灰度测试<a href="#灰度测试" class="hash-link" aria-label="灰度测试的直接链接" title="灰度测试的直接链接">​</a></h3><p>灰度测试是研发流程中不可或缺的一个环节。传统的研发流程中，测试和灰度环节，需要测试同学做各种各样的配置，如绑定host、配置jvm参数、环境变量等等，比较麻烦。经过多年的实践，阿里巴巴内部的测试和灰度对开发和测试非常友好，通过环境隔离功能来保证请求在指定的机器集群处理，开发和测试不需要做任何做任何配置，大大提高了研发效率。</p><a name="37555cc2"></a><h2 class="anchor anchorWithStickyNavbar_LWe7" id="nacos如何做环境隔离">Nacos如何做环境隔离<a href="#nacos如何做环境隔离" class="hash-link" aria-label="Nacos如何做环境隔离的直接链接" title="Nacos如何做环境隔离的直接链接">​</a></h2><p>前面两节讲到了环境的概念、环境隔离有哪些作用，本节将向大家介绍如何把Nacos按照前面的思路隔离成多个环境。Nacos脱胎于阿里巴巴中间件部门的软负载小组，在环境隔离方面我们有多年的经验。下面简单介绍下把Nacos隔离为多个物理集群，nacos客户端不需要做任何代码改动即可实现环境自动路由。</p><a name="b6724cff"></a><h3 class="anchor anchorWithStickyNavbar_LWe7" id="原理">原理<a href="#原理" class="hash-link" aria-label="原理的直接链接" title="原理的直接链接">​</a></h3><p>在开始前，我们先做一些约束：</p><ul><li>一台机器上部署的应用都在一个环境内；</li><li>一个应用进程内默认情况下只连一个环境的Nacos；</li><li>通过某种手段可以拿到客户端所在机器ip；</li><li>用户对机器的网段有规划；</li></ul><p>下面简单介绍一下基本原理：</p><ul><li>我们知道网络中32位的ipv4可以划分为很多网段，如192.168.1.0/24这种，并且一般稍大型的公司都会有网段规划，按照一定的用途划分网段。我们可以利用这个原理做环境隔离，即不同网段的IP属于不同的环境，如192.168.1.0/24属于环境A， 192.168.2.0/24属于环境B等。</li><li>使用过Nacos的应该知道，有两种方式初始化Nacos客户端实例，一种是直接告诉客户端nacos服务端的IP；另一种是告诉客户端一个endpoint，客户端通过HTTP请求到endpoint查询nacos服务端IP列表。我们利用Nacos第二种初始化方式。</li><li>增强endpoint的功能。在endpoint端配置网段和环境的映射关系，endpoint在接收到客户端的请求之后，根据客户端的来源IP所属网段，计算出该客户端所属环境，然后找到对应环境的IP列表返回给客户端。如下图</li></ul><p><img loading="lazy" src="https://cdn.nlark.com/yuque/0/2019/png/333810/1559699221719-b127d968-2374-4fad-b433-733f47642bf0.png#alt=undefined" class="img_ev3q"></p><a name="f172b185"></a><h2 class="anchor anchorWithStickyNavbar_LWe7" id="一个环境隔离server的示例">一个环境隔离server的示例<a href="#一个环境隔离server的示例" class="hash-link" aria-label="一个环境隔离server的示例的直接链接" title="一个环境隔离server的示例的直接链接">​</a></h2><p>上面讲了基于IP段做环境隔离的约束和基本原理，那么如何实现一个地址服务器呢。最简单的方法是基于nginx实现，利用nginx的geo模块，做IP端和环境的映射，然后利用nginx返回静态文件内容。</p><ul><li><p>安装nginx <a href="http://nginx.org/en/docs/install.html" target="_blank" rel="noopener noreferrer">http://nginx.org/en/docs/install.html</a></p></li><li><p>在nginx-proxy.conf中配置geo映射，<a href="http://nginx.org/en/docs/http/ngx_http_geo_module.html" target="_blank" rel="noopener noreferrer">参考这里</a></p></li></ul><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">geo $env {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  default        &quot;&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  192.168.1.0/24 -env-a;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  192.168.2.0/24 -env-b;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ul><li>配置nginx根路径及转发规则，这里只需要简单的返回静态文件的内容；</li></ul><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># 在http模块中配置根路径</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">root                    /tmp/htdocs;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 在server模块中配置</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">location / {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  rewrite ^(.*)$  /$1$env break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ul><li>配置Nacos服务端IP列表配置文件，在/tmp/hotdocs/nacos目录下配置以环境名结尾的文件，文件内容为IP，一行一个</li></ul><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$ll /tmp/hotdocs/nacos/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">total 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-rw-r--r-- 1 user1 users 0 Mar  5 08:53 serverlist</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-rw-r--r-- 1 user1 users 0 Mar  5 08:53 serverlist-env-a</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-rw-r--r-- 1 user1 users 0 Mar  5 08:53 serverlist-env-b</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$cat /tmp/hotdocs/nacos/serverlist</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">192.168.1.2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">192.168.1.3</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ul><li>验证</li></ul><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">curl &#x27;localhost:8080/nacos/serverlist&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">192.168.1.2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">192.168.1.3</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>至此， 一个简单的根据IP网段做环境隔离的示例已经可以工作了，不同网段的nacos客户端会自动获取到不同的Nacos服务端IP列表，实现环境隔离。这种方法的好处是用户不需要配置任何参数，各个环境的代码和配置是一样的，但需要提供底层服务的同学做好网络规划和相关配置。</p><a name="25f9c7fa"></a><h2 class="anchor anchorWithStickyNavbar_LWe7" id="总结">总结<a href="#总结" class="hash-link" aria-label="总结的直接链接" title="总结的直接链接">​</a></h2><p>本文简单介绍了环境隔离的概念，环境隔离的三个好处以及Nacos如何基于网段做环境隔离。最后，给出了一个基于nginx做endpoint服务端的环境隔离配置示例。本文只是列出了一种可行的方法，不排除有更优雅的实现方法，如果大家有更好的方法可以看到nacos社区或<a href="https://nacos.io/" target="_blank" rel="noopener noreferrer">官网</a>贡献方案。</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><meta itemprop="description" content="阿里巴巴服务注册中心产品ConfigServer 10年技术发展回顾"><meta itemprop="keywords" content="nacos,configserver,alibaba"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/zh-cn/blog/alibaba-configserver">阿里巴巴服务注册中心产品ConfigServer 10年技术发展回顾</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2023-10-10T11:47:41.000Z" itemprop="datePublished">2023年10月10日</time> · <!-- -->阅读需 22 分钟</div></header><div class="markdown" itemprop="articleBody"><p>作者：阿里巴巴高级技术专家，许真恩(慕义)</p><p>文章概要：本文简单描述了Eureka1.0存在的架构问题，Eureka2.0设想的架构。详细回顾了阿里巴巴的服务注册中心ConfigServer产品从2008年建设元年至今经历的关键架构演进。通过这个文章你会对基于AP模式的注册中心在技术发展过程中将会碰到的问题有所感知。</p><h1>Eureka1.0架构存在的问题</h1><p>Eureka作为Netflix公司力推和SpringCloud微服务标配的注册中心开源解决方案，其Eureka 2.0 (Discontinued)的消息在社区引起了不小的骚动；其实早在2015年社区就已经放出了2.0架构的升级设想，但是3年的时间过去，等到的确是Discontinued的消息，虽然2.0的代码在github的主页上也已经放出，但是告诫用户要自行承担当中的使用风险。我想不会有人真的把2.0直接投入到生产中使用。</p><p>对于为什么要做Eureka2.0，其官方的wiki中的Why Eureka 2.0和Eureka 2.0 Improvements做了如下的说明</p><ul><li>Only support homogenous client views: Eureka servers only expects the client to always get the entire registry and does not allow to get specific applications/VIP addresses. This imposes a memory limitation on all clients registering with Eureka, even if they need a very small subset of the Eureka’s registry.</li><li>Only supports scheduled updates: Eureka client follows a poll model to fetch updates from the server routinely. This imposes an overhead on the client of doing a scheduled call to the server, even if there are no changes and also delays the updates by the poll interval.</li><li>Replication algorithm limits scalability: Eureka follows a broadcast replication model i.e. all the servers replicate data and heartbeats to all the peers. This is simple and effective for the data set that eureka contains however replication is implemented by relaying all the HTTP calls that a server receives as is to all the peers. This limits scalability as every node has to withstand the entire write load on eureka.</li></ul><p>Although Eureka 2.0 provides a more richer feature set, the above limitations are the major driving factors for the changes proposed in this version.
Based on the above motivations, Eureka 2.0 achieves the following improvements:</p><ul><li>Interest based subscription model for registry data: A client of Eureka is able to select a part of the instance registry in which it is interested in and the eureka server only sends information about that part of the registry. Eg: A client can say I am only interested in application “WebFarm” and then the server will only send information about WebFarm instances. Eureka server provides various selection criterions and a way to update this interest set dynamically.</li><li>Push model from the server for any changes to the interest set: Instead of the current pull model from the client, Eureka servers pushes updates for changes to the interest set, to the client.</li><li>Optimized replication: As Eureka 1.0, Eureka 2.0 also follows a broadcast replication model i.e. every node replicates data to all other nodes. However, the replication algorithm is much more optimized eliminating the need of sending heartbeats for every instance in the registry. This drastically reduce the replication traffic and achieves much higher scalability.</li><li>Auto-scaled Eureka servers: Eureka 2.0 divides the read (discovery of data) and write (registration) concerns into separate clusters. Since, the write load is predictable (proportional to the number of instances in a region), the write cluster is pre-scaled. On the other hand, read load is unpredictable (proportional to subscriptions from clients) and hence the read farm is auto-scaled.</li><li>Audit log: Eureka 2.0 provides an elaborate audit log for any change done to the registry. This helps Eureka owners as well as users to get insight into debugging the state of individual application instances as exists in Eureka. The audit log by default is persisted to a log file, but different persistent storages can be plugged-in.</li><li>Dashboard: Eureka 2.0 provides a rich dashboard (as opposed to very rudimentary dashboard of Eureka 1.0) with insights into Eureka internals with respect to registry views, server health, subscription state, audit log, etc.</li></ul><p> 简单翻译总结，也就是Eureka1.0的架构主要存在如下的不足：</p><ul><li>订阅端拿到的是服务的全量的地址：这个对于客户端的内存是一个比较大的消耗，特别在多数据中心部署的情况下，某个数据中心的订阅端往往只需要同数据中心的服务提供端即可。</li><li>pull模式：客户端采用周期性向服务端主动pull服务数据的模式（也就是客户端轮训的方式），这个方式存在实时性不足以及无谓的拉取性能消耗的问题。</li><li>一致性协议：Eureka集群的多副本的一致性协议采用类似“异步多写”的AP协议，每一个server都会把本地接收到的写请求（register/heartbeat/unregister/update）发送给组成集群的其他所有的机器（Eureka称之为peer），特别是hearbeat报文是周期性持续不断的在client-&gt;server-&gt;all peers之间传送；这样的一致性算法，导致了如下问题<ul><li>每一台Server都需要存储全量的服务数据，Server的内存明显会成为瓶颈。</li><li>当订阅者却来越多的时候，需要扩容Eureka集群来提高读的能力，但是扩容的同时会导致每台server需要承担更多的写请求，扩容的效果不明显。</li><li>组成Eureka集群的所有server都需要采用相同的物理配置，并且只能通过不断的提高配置来容纳更多的服务数据</li></ul></li></ul><p>Eureka2.0主要就是为了解决上述问题而提出的，主要包含了如下的改进和增强</p><ul><li>数据推送从pull走向push模式，并且实现更小粒度的服务地址按需订阅的功能。</li><li>读写分离：写集群相对稳定，无需经常扩容；读集群可以按需扩容以提高数据推送能力。</li><li>新增审计日志的功能和功能更丰富的Dashboard。</li></ul><p>Eureka1.0版本存在的问题以及Eureka2.0架构设想和阿里巴巴内部的同类产品ConfigServer所经历的阶段非常相似（甚至Eureka2.0如果真的落地后存在的问题，阿里巴巴早已经发现并且已经解决），下面我带着你来回顾一下我们所经历过的。</p><h1>阿里巴巴服务注册中心ConfigServer技术发现路线</h1><p>阿里巴巴早在2008就开始了服务化的进程，在那个时候就就已经自研出服务发现解决方案（内部产品名叫ConfigServer）。</p><p>当2012年9月1号Eureka放出第一个1.1.2版本的时候，我们把ConfigServer和Eureka进行了深度的对比，希望能够从Eureka找到一些借鉴来解决当时的ConfigServer发展过程中碰到的问题（后面会提到）；然而事与愿违，我们已经发现Eureka1.x架构存在比较严重的扩展性和实时性的问题（正如上面所描述的），这些问题ConfigServer当时的版本也大同小异的存在，我们在2012年底对ConfigServer的架构进行了升级来解决这些问题。</p><p>当2015年Eureka社区放出2.0架构升级的声音的时候，我们同样第一时间查看了2.0的目标架构设计，我们惊奇的发现Eureka的这个新的架构同2012年底ConfigServer的架构非常相似，当时一方面感慨“英雄所见略同”，另一方也有些失望，因为ConfigServer2012年的架构早就无法满足阿里巴巴内部的发展诉求了。</p><p>下面我从头回顾一下，阿里巴巴的ConfigServer的技术发展过程中的几个里程碑事件。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="2008年无configserver的时代">2008年，无ConfigServer的时代<a href="#2008年无configserver的时代" class="hash-link" aria-label="2008年，无ConfigServer的时代的直接链接" title="2008年，无ConfigServer的时代的直接链接">​</a></h2><p>借助用硬件负载设备F5提供的vip功能，服务提供方只提供vip和域名信息，调用方通过域名方式调用，所有请求和流量都走F5设备。</p><p>遇到的问题：</p><ul><li>负载不均衡：对于长连接场景，F5不能提供较好的负载均衡能力。如服务提供方发布的场景，最后一批发布的机器，基本上不能被分配到流量。需要在发布完成后，PE手工去断开所有连接，重新触发连接级别的负载均衡。</li><li>流量瓶颈：所有的请求都走F5设备，共享资源，流量很容易会打满网卡，会造成应用之间的相互影响。</li><li>单点故障：F5设备故障之后，所有远程调用会被终止，导致大面积瘫痪。</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="2008年configserver单机版v10">2008年，ConfigServer单机版V1.0<a href="#2008年configserver单机版v10" class="hash-link" aria-label="2008年，ConfigServer单机版V1.0的直接链接" title="2008年，ConfigServer单机版V1.0的直接链接">​</a></h2><p>单机版定义和实现了服务发现的关键的模型设计（包括服务发布，服务订阅，健康检查，数据变更主动推送，这个模型至今仍然适用），应用通过内嵌SDK的方式接入实现服务的发布和订阅；这个版本很重要的一个设计决策就是服务数据变更到底是pull还是push的模式，我们从最初就确定必须采用push的模式来保证数据变更时的推送实时性（Eureka1.x的架构采用的是pull的模式）</p><p>当时，HSF和Notify就是采用单机版的ConfigServer来完成服务的发现和topic的发现。单机版的ConfigServer和HSF、Notify配合，采用服务发现的技术，让请求通过端到端的方式流动，避免产生流量瓶颈和单点故障。ConfigServer可以动态的将服务地址推送到客户端，服务调用者可以知道所有提供此服务的机器，每个请求都可以通过随机或者轮询的方式选择服务端，做到请求级别的负载均衡。这个版本已经能很好的解决F5设备不能解决的三个问题。</p><p>但是单机版本的问题也非常明显，不具备良好的容灾性；</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="2009年初configserver单机版v15">2009年初，ConfigServer单机版V1.5<a href="#2009年初configserver单机版v15" class="hash-link" aria-label="2009年初，ConfigServer单机版V1.5的直接链接" title="2009年初，ConfigServer单机版V1.5的直接链接">​</a></h2><p>单机版的ConfigServer所面临的问题就是当ConfigServer在发布/升级的时候，如果应用刚好也在发布，这个时候会导致订阅客户端拿不到服务地址的数据，影响服务的调用；所以当时我们在SDK中加入了本地的磁盘缓存的功能，应用在拿到服务端推送的数据的时候，会先写入本地磁盘，然后再更新内存数据；当应用重启的时候，优先从本地磁盘获取服务数据；通过这样的方式解耦了ConfigServer和应用发布的互相依赖；这个方式沿用至今。（我很惊讶，Eureka1.x的版本至今仍然没有实现客户端磁盘缓存的功能，难道Eureka集群可以保持100%的SLA吗？）</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="2009年7月configserver集群版本v20">2009年7月，ConfigServer集群版本V2.0<a href="#2009年7月configserver集群版本v20" class="hash-link" aria-label="2009年7月，ConfigServer集群版本V2.0的直接链接" title="2009年7月，ConfigServer集群版本V2.0的直接链接">​</a></h2><p>ConfigServer的集群版本跟普通的应用有一些区别：普通的应用通过服务拆分后，已经属于无状态型，本身已经具备良好的可扩展性，单机变集群只是代码多部署几台；ConfigServer是有状态的，内存中的服务信息就是数据状态，如果要支持集群部署，这些数据要不做分片，要不做全量同步；由于分片的方案并没有真正解决数据高可用的问题（分片方案还需要考虑对应的failover方案），同时复杂度较高；所以当时我们选择了单机存储全量服务数据全量的方案。为了简化数据同步的逻辑，服务端使用客户端模式同步：服务端收到客户端请求后，通过客户端的方式将此请求转发给集群中的其他的ConfigServer，做到同步的效果，每一台ConfigServer都有全量的服务数据。</p><p>这个架构同Eureka1.x的架构惊人的相似，所以很明显的Eureka1.x存在的问题我们也存在；当时的缓解的办法是我们的ConfigServer集群全部采用高配物理来部署。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="2010年底configserver集群版v25">2010年底，ConfigServer集群版V2.5<a href="#2010年底configserver集群版v25" class="hash-link" aria-label="2010年底，ConfigServer集群版V2.5的直接链接" title="2010年底，ConfigServer集群版V2.5的直接链接">​</a></h2><p>基于客户端模式在集群间同步服务数据的方案渐渐无以为继了，特别是每次应用在发布的时候产生了大量的服务发布和数据推送，服务器的网卡经常被打满，同时cmsgc也非常频繁；我们对数据同步的方案进行了升级，去除了基于客户端的同步模式，采用了批量的基于长连接级别的数据同步+周期性的renew的方案来保证数据的一致性（这个同步方案当时还申请了国家专利）；这个版本还对cpu和内存做了重点优化，包括同步任务的合并，推送任务的合并，推送数据的压缩，优化数据结构等；</p><p>这个版本是ConfigServer历史上一个比较稳定的里程碑版本。</p><p>但是随着2009年天猫独创的双十一大促活动横空出世，服务数量剧增，应用发布时候ConfigServer集群又开始了大面积的抖动，还是体现在内存和网卡的吃紧，甚至渐渐到了fullgc的边缘；为了提高数据推送能力，需要对集群进行扩容，但是扩容的同时又会导致每台服务器的写能力下降，我们的架构到了“按下葫芦浮起瓢”的瓶颈。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="2012年底configserver集群版v30">2012年底，ConfigServer集群版V3.0<a href="#2012年底configserver集群版v30" class="hash-link" aria-label="2012年底，ConfigServer集群版V3.0的直接链接" title="2012年底，ConfigServer集群版V3.0的直接链接">​</a></h2><p>在2011年双十一之前我们完成了V3架构的落地，类似Eureka2.0所设计的读写分离的方案，我们把ConfigServer集群拆分成session和data两个集群，客户端分片的把服务数据注册到session集群中，session集群会把数据异步的写到data集群，data集群完成服务数据的聚合后，把压缩好的服务数据推送到session层缓存下来，客户端可以直接从session层订阅到所需要的服务数据；这个分层架构中，session是分片存储部分的服务数据的（我们设计了failover方案），data存储的是全量服务数据（天生具备failover能力）；</p><p>data集群相对比较稳定，不需要经常扩容；session集群可以根据数据推送的需求很方便的扩容（这个思路和Eureka2.0所描述的思路是一致的）；session的扩容不会给data集群带来压力的增加。session集群我们采用低配的虚拟机即可满足需求，data由于存储是全量的数据我们仍然采用了相对高配的物理机（但是同V2.5相比，对物理机的性能要求已经答复下降）</p><p>这个版本也是ConfigServer历史上一个划时代的稳定的大版本。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="2014年configserver集群版v35">2014年，ConfigServer集群版V3.5<a href="#2014年configserver集群版v35" class="hash-link" aria-label="2014年，ConfigServer集群版V3.5的直接链接" title="2014年，ConfigServer集群版V3.5的直接链接">​</a></h2><p>2013年，阿里巴巴开始落地了异地多活方案，从一个IDC渐渐往多个IDC跨越，随之而来的对流量的精细化管控要求越来越高（比如服务的同机房调用，服务流量的调拨以支持灰度能力等），基于这个背景ConfigServer引入了服务元数据的概念，支持对服务和IP进行元数据的打标来满足各种各样的服务分组诉求。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="2017年configserver集群版v40">2017年，ConfigServer集群版V4.0<a href="#2017年configserver集群版v40" class="hash-link" aria-label="2017年，ConfigServer集群版V4.0的直接链接" title="2017年，ConfigServer集群版V4.0的直接链接">​</a></h2><p>V3版本可见的一个架构的问题就是data集群是存储全量的服务数据的，这个随着服务数的与日俱增一定会走到升级物理机配置也无法解决问题的情况（我们当时已经在生产使用了G1的垃圾回收算法），所以我们继续对架构进行升级，基于V3的架构进行升级其实并不复杂；session层的设计保持不变，我们把data进行分片，每一个分片同样按照集群的方式部署以支持failover的能力；</p><table><thead><tr><th></th><th>ConfigServer</th><th>Eureka</th></tr></thead><tbody><tr><td>2008年</td><td>V1.0：单机版，定义了服务发现的领域模型</td><td></td></tr><tr><td>2009年初</td><td>V1.5：应用和ConfigServer集群发布解耦</td><td></td></tr><tr><td>2009年7月</td><td>V2.0：基于客户端模式同步数据，支持集群部署</td><td></td></tr><tr><td>2010年底</td><td>V2.5：优化集群间数据同步模式，申请国家专利。</td><td></td></tr><tr><td>2012年9月1号</td><td></td><td>Eureka1.0正式开源</td></tr><tr><td>2012年底</td><td>V3.0：支持session和data分层部署</td><td></td></tr><tr><td>2014年</td><td>V3.5：支持异地多活等细分场景</td><td></td></tr><tr><td>2015年</td><td></td><td>Eureka2.0架构升级方案公布</td></tr><tr><td>2017年</td><td>V4.0：支持data分片能力</td><td></td></tr><tr><td>2018年7月</td><td></td><td>Eureka2.0架构升级宣布停止</td></tr></tbody></table><h1>Nacos</h1><p>作为同属于AP类型的注册中心，Eureka和ConfigServer发展过程中所面临的诸多问题有很大的相似性，但是阿里巴巴这些年业务的跨越式发展，每年翻番的服务规模，不断的给ConfigServer的技术架构演进带来更高的要求和挑战，我们有更多的机会在生产环境发现和解决一个个问题的过程中，做架构的一代代升级。我们正在计划通过开源的手段把我们这些年在生产环境上的实践经验通过Nacos(<a href="http://nacos.io" target="_blank" rel="noopener noreferrer">链接</a>)产品贡献给社区，一方面能够助力和满足同行们在微服务落地过程当中对工业级注册中心的诉求，另一方面也希望通过开源社区及开源生态的协同发展给ConfigServer带来更多的可能性。</p><p>炎炎夏日，在Eureka 2.0 (Discontinued) 即将结束的时候，在同样的云原生时代，Nacos却正在迎来新生，技术演进和变迁的趣味莫过于此。</p><p>Nacos将努力继承Eureka未竟的遗志，扛着AP系注册中心的旗帜继续前行，不同的是Nacos更关注DNS-based Service Discovery以及与Kubernetes体系的融会贯通。</p><p>我们看不透未来，却仍将与同行们一起上下求索，砥砺前行。</p><p>最后附上Nacos的架构图。</p><p><img loading="lazy" src="https://cdn.yuque.com/lark/0/2018/png/12425/1530856061648-7180b97f-b61d-4127-924e-a0743b9e9d5a.png" alt="屏幕快照 2018-06-28 下午4.58.59.png | center | 748x544" class="img_ev3q"></p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><meta itemprop="description" content="关于Nacos默认token.secret.key及server.identity风险说明及解决方案公告"><meta itemprop="keywords" content="nacos,auth,risk,token.secret.key,server.identity"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/zh-cn/blog/announcement-token-secret-key">关于Nacos默认token.secret.key及server.identity风险说明及解决方案公告</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2023-10-10T11:47:41.000Z" itemprop="datePublished">2023年10月10日</time> · <!-- -->阅读需 5 分钟</div></header><div class="markdown" itemprop="articleBody"><p>近期Nacos社区收到关于Nacos鉴权功能通过<code>token.secret.key</code>默认值进行撞击，绕过身份验证安全漏洞的问题。社区在2.2.0.1和1.4.5版本已移除了自带的默认值，并在<code>token.secret.key</code>未传入或非法时阻止Nacos节点启动来提醒用户设置自定义<code>token.secret.key</code>。考虑到现在的控制台登陆页面并没有进行模块化，无法和是否开启鉴权功能关联，因此暂时需要强制设置<code>token.secret.key</code>，社区正在进行控制台登陆页面和鉴权功能的关联，待完成后，<strong>未开启鉴权</strong>的集群将不再强制需要<code>token.secret.key</code>，<strong>开启</strong>后仍然强制需要。</p><p>同时Nacos社区还收到关于通过<code>nacos.core.auth.server.identity.key</code> 和 <code>nacos.core.auth.server.identity.value</code>默认值进行撞击，绕过身份验证安全漏洞的问题。社区在2.2.1和1.4.5版本已移除了自带的默认值，并在开启鉴权后，未填写这两个参数时阻止Nacos节点启动来提醒用户设置自定义的<code>nacos.core.auth.server.identity.key</code> 和 <code>nacos.core.auth.server.identity.value</code>。</p><blockquote><p>说明：这两个默认值原意是为了方便新用户在快速搭建新集群进行使用时可以减少一些繁琐步骤，更简单的使用nacos，在实际部署时提供机制修改配置来提高安全性；随着社区用户对安全性要求提升，默认值可能会导致部分用户未修改直接使用时出现安全风险，因此Nacos社区去除了默认值，并在启动时进行校验，阻止启动提示用户配置。</p></blockquote><p>使用旧版本的用户请根据<a href="https://nacos.io/zh-cn/docs/v2/guide/user/auth.html" target="_blank" rel="noopener noreferrer">文档</a>进行环境检查，查看是否使用了默认的<code>token.secret.key</code>、<code>nacos.core.auth.server.identity.key</code> 和 <code>nacos.core.auth.server.identity.value</code>，如仍然使用默认值，请参考文档内容尽快进行修改。</p><p>新部署环境请使用最新2.2.1版本部署，并根据文档设置<code>token.secret.key</code>、<code>nacos.core.auth.server.identity.key</code> 和 <code>nacos.core.auth.server.identity.value</code>，并尽快修改默认密码。</p><p><a href="https://github.com/alibaba/nacos/releases/tag/2.2.1" target="_blank" rel="noopener noreferrer">Download page</a>.</p><h1>关于Nacos的部署建议</h1><p>Nacos 定义为一个应用服务发现和配置管理中间件服务，这类应用一般应该部署于<strong>内部网络环境</strong>，因此不建议用户将Nacos暴露在<strong>公网环境</strong>。</p><p>同时应开启鉴权，设置自定义<code>token.secret.key</code>、<code>nacos.core.auth.server.identity.key</code> 和 <code>nacos.core.auth.server.identity.value</code>，并修改<code>nacos</code>用户的密码，提高安全性。</p><p>另外，即使升级到最新版本，开启鉴权并修改了<code>token.secret.key</code>、<code>nacos.core.auth.server.identity.key</code>、<code>nacos.core.auth.server.identity.value</code>和<code>nacos</code>用户的密码，也请不要暴露在<strong>公网环境</strong>使用。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="关于变更tokensecretkey对正在运行程序的影响及初步解决方式">关于变更token.secret.key对正在运行程序的影响及初步解决方式<a href="#关于变更tokensecretkey对正在运行程序的影响及初步解决方式" class="hash-link" aria-label="关于变更token.secret.key对正在运行程序的影响及初步解决方式的直接链接" title="关于变更token.secret.key对正在运行程序的影响及初步解决方式的直接链接">​</a></h2><p>修改<code>token.secret.key</code>并重启Nacos Server端后，来自Nacos Client的请求将会因无效token被拒绝。直到客户端到达旧token的TTL时间后，才会重新去获取新token。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="解决方式">解决方式<a href="#解决方式" class="hash-link" aria-label="解决方式的直接链接" title="解决方式的直接链接">​</a></h3><p>目前该问题的解决有一个关联<a href="https://github.com/alibaba/nacos/issues/10105" target="_blank" rel="noopener noreferrer">ISSUE</a>，欢迎大家进入讨论。</p><p>在修改<code>token.secret.key</code>前，先修改<code>token.expire.seconds</code>为5，客户端默认<code>每5s</code>检查一次token是否过期，需要让客户端尽快过期掉旧token。</p><div class="language-properties codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-properties codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># 2.1.0版本前</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">nacos.core.auth.default.token.expire.seconds=5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 2.1.0版本及更高版本</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">nacos.core.auth.plugin.nacos.token.expire.seconds=5</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>修改<code>token.expire.seconds</code>后重启集群，运行一段时间（超过原<code>token.expire.seconds</code>值，以保证所有客户端已经获取到新TTL）</p><blockquote><p>注意：修改后会导致客户端较为频繁地调用login接口，修改前请确保Nacos Server集群的资源足够。</p></blockquote><p>最后将<code>token.secret.key</code>修改为新值，并重启集群，<code>token.expire.seconds</code>值请酌情修改。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="关于变更nacoscoreauthserveridentitykey-和-nacoscoreauthserveridentityvalue对正在运行程序的影响">关于变更<code>nacos.core.auth.server.identity.key</code> 和 <code>nacos.core.auth.server.identity.value</code>对正在运行程序的影响<a href="#关于变更nacoscoreauthserveridentitykey-和-nacoscoreauthserveridentityvalue对正在运行程序的影响" class="hash-link" aria-label="关于变更nacoscoreauthserveridentitykey-和-nacoscoreauthserveridentityvalue对正在运行程序的影响的直接链接" title="关于变更nacoscoreauthserveridentitykey-和-nacoscoreauthserveridentityvalue对正在运行程序的影响的直接链接">​</a></h2><p>修改<code>nacos.core.auth.server.identity.key</code> 和 <code>nacos.core.auth.server.identity.value</code>不会对当前正在运行造成影响，但可能会导致变更同步失败或自动摘除实例失败。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="解决方式-1">解决方式<a href="#解决方式-1" class="hash-link" aria-label="解决方式的直接链接" title="解决方式的直接链接">​</a></h3><p>按照<a href="https://nacos.io/zh-cn/docs/v2/guide/user/auth.html" target="_blank" rel="noopener noreferrer">文档</a>提示，先开启userAgent白名单，在变更新<code>server.identity</code>后，立刻关闭userAgent白名单。</p><p>或保证变更<code>server.identity</code>期间，不进行业务应用的变更。</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><meta itemprop="description" content="本文为您介绍 Apache APISIX、Nacos 基本概念以及注册中心的作用，并为您展示了 Apache APISIX 基于 Nacos 实现服务发现的具体操作"><meta itemprop="keywords" content="Apache APISIX"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/zh-cn/blog/apisix">Apache APISIX 基于 Nacos 实现服务发现</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2023-10-10T11:47:41.000Z" itemprop="datePublished">2023年10月10日</time> · <!-- -->阅读需 9 分钟</div></header><div class="markdown" itemprop="articleBody"><h2 class="anchor anchorWithStickyNavbar_LWe7" id="关于-apache-apisix">关于 Apache APISIX<a href="#关于-apache-apisix" class="hash-link" aria-label="关于 Apache APISIX的直接链接" title="关于 Apache APISIX的直接链接">​</a></h2><p>Apache APISIX 是一个动态、实时、高性能的 API 网关，提供负载均衡、动态上游、灰度发布、服务熔断、身份认证、可观测性等丰富的流量管理功能。Apache APISIX 不仅拥有众多实用的插件，而且支持插件动态变更和热插拔。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="关于-nacos">关于 Nacos<a href="#关于-nacos" class="hash-link" aria-label="关于 Nacos的直接链接" title="关于 Nacos的直接链接">​</a></h2><p><strong>Nacos</strong> 是阿里巴巴开源的一个易于使用的动态服务发现、配置和服务管理平台。它提供了一组简单易用的特性集，可以帮助您快速实现动态服务发现，服务配置，服务元数据及流量管理，让您更敏捷和容易地构建，交付和管理微服务平台。Nacos 是构建以“服务”为中心的现代应用架构（例如微服务范式、云原生范式）的服务基础设施。</p><h1>注册中心</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="什么是注册中心">什么是注册中心<a href="#什么是注册中心" class="hash-link" aria-label="什么是注册中心的直接链接" title="什么是注册中心的直接链接">​</a></h2><p>服务注册中心是服务要实现服务化管理的核心组件，类似于目录服务的作用，也是微服务架构中最基础的设施之一，主要用来存储服务信息，譬如服务提供者 URL 、路由信息等。注册中心的实现是通过一种映射的方式，将复杂的服务端信息映射为简单易懂的信息提供给客户端。</p><p>注册中心的核心功能为以下三点：</p><ol><li>服务注册：<strong>服务提供方</strong>向<strong>注册中心</strong>进行注册。</li><li>服务发现：<strong>服务消费方</strong>可以通过注册中心寻找到服务提供方的调用路由信息。</li><li>健康检测：确保注册到注册中心的服务节点是可以被正常调用的，避免无效节点导致的调用资源浪费等问题。</li></ol><h2 class="anchor anchorWithStickyNavbar_LWe7" id="为什么需要注册中心">为什么需要注册中心？<a href="#为什么需要注册中心" class="hash-link" aria-label="为什么需要注册中心？的直接链接" title="为什么需要注册中心？的直接链接">​</a></h2><p>注册中心本质上是为了<strong>解耦服务提供者和服务消费者</strong>，在微服务体系中，各个业务服务之间会频繁互相调用，并且需要对各个服务的 IP、port 等路由信息进行统一的管理。但是要如何进行管理呢？我们可以通过注册中心的 <strong>服务注册</strong> 功能将已有服务的相关信息提供到统一的注册中心进行管理。</p><p>通过上述描述，您可以了解到注册中心可以帮助用户通过映射快速找到服务和服务地址。随着业务更新迭代，服务会频繁发生变化，在服务端中注册了新的服务或者服务宕机后，客户端仍然可以通过注册中心的 <strong>服务发现</strong> 功能拉取服务列表，如果注册中心的服务节点发生变更，注册中心会发送请求通知客户端重新拉取。</p><p>如果服务端的服务突然宕机，并且没有向注册中心反馈，客户端可以通过注册中心的<strong>健康检查</strong>功能，进行固定时间间隔的主动上报心跳方式向服务端表明自己的服务状态。如果服务状态异常，则会通知注册中心，注册中心可以及时把已经宕机的服务节点进行剔除，避免资源的浪费。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="apache-apisix--nacos-为用户提供了什么应用场景">Apache APISIX + Nacos 为用户提供了什么应用场景？<a href="#apache-apisix--nacos-为用户提供了什么应用场景" class="hash-link" aria-label="Apache APISIX + Nacos 为用户提供了什么应用场景？的直接链接" title="Apache APISIX + Nacos 为用户提供了什么应用场景？的直接链接">​</a></h2><p>Apache APISIX + Nacos 可以将各个微服务节点中与业务无关的各项控制，集中在 Apache APISIX 中进行统一管理，即通过Apache APISIX 实现接口服务的代理和路由转发的能力。各个微服务在 Nacos 上注册后，Apache APISIX 可以通过 Nacos 的服务发现功能获取服务列表，查找对应的服务地址从而实现动态代理。</p><p><img loading="lazy" alt="img" src="/zh-cn/assets/images/apisix-f63e74884230417502884336fd02c92a.png" width="1280" height="913" class="img_ev3q"></p><h1>Apache APISIX 基于 Nacos 实现服务发现</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="前提条件">前提条件<a href="#前提条件" class="hash-link" aria-label="前提条件的直接链接" title="前提条件的直接链接">​</a></h2><p>本文操作基于以下环境进行。</p><ul><li>操作系统 Centos 7.9。</li><li>已安装 Apache APISIX 12.1.0，详情请参考：<a href="https://apisix.apache.org/zh/docs/apisix/how-to-buildhttps://apisix.apache.org/zh/docs/apisix/how-to-build" target="_blank" rel="noopener noreferrer">Apache APISIX how-to-bulid</a>。</li><li>已安装 Nacos 2.0.4 及以上版本，详情请参考：<a href="https://nacos.io/zh-cn/docs/quick-start.html" target="_blank" rel="noopener noreferrer">quick start</a>。</li><li>已安装 Node.js，详情请参考：<a href="https://github.com/nodejs/help/wiki/Installation" target="_blank" rel="noopener noreferrer">node.js Installation</a>。</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="步骤一服务注册">步骤一：服务注册<a href="#步骤一服务注册" class="hash-link" aria-label="步骤一：服务注册的直接链接" title="步骤一：服务注册的直接链接">​</a></h2><ol><li>使用 Node.js 的 Koa 框架在 3005 端口启动一个简单的测试服务作为<a href="https://apisix.apache.org/zh/docs/apisix/admin-api#upstream" target="_blank" rel="noopener noreferrer">上游（Upstream）</a>。</li></ol><div class="language-JavaScript codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-JavaScript codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">const Koa = require(&#x27;koa&#x27;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const app = new Koa();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">app.use(async ctx =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ctx.body = &#x27;Hello World&#x27;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">});</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">app.listen(3005);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol start="2"><li>在命令行中通过请求 Nacos Open API 的方式进行服务注册。</li></ol><div class="language-Bash codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-Bash codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">curl -X POST &#x27;http://127.0.0.1:8848/nacos/v1/ns/instance?serviceName=APISIX-NACOS&amp;ip=127.0.0.1&amp;port=3005&amp;ephemeral=false&#x27;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol start="3"><li>执行服务注册后使用以下命令查询当前服务情况。</li></ol><div class="language-Bash codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-Bash codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">curl -X GET &#x27;http://127.0.0.1:8848/nacos/v1/ns/instance/list?serviceName=APISIX-NACOS&#x27;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>正确返回结果示例如下：</p><div class="language-JSON codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-JSON codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  &quot;name&quot;: &quot;DEFAULT_GROUP@@APISIX-NACOS&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  &quot;groupName&quot;: &quot;DEFAULT_GROUP&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  &quot;clusters&quot;: &quot;&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  &quot;cacheMillis&quot;: 10000,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  &quot;hosts&quot;: [</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      &quot;instanceId&quot;: &quot;127.0.0.1#3005#DEFAULT#DEFAULT_GROUP@@APISIX-NACOS&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      &quot;ip&quot;: &quot;127.0.0.1&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      &quot;port&quot;: 3005,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      &quot;weight&quot;: 1.0,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      &quot;healthy&quot;: true,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      &quot;enabled&quot;: true,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      &quot;ephemeral&quot;: true,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      &quot;clusterName&quot;: &quot;DEFAULT&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      &quot;serviceName&quot;: &quot;DEFAULT_GROUP@@APISIX-NACOS&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      &quot;metadata&quot;: {},</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      &quot;instanceHeartBeatInterval&quot;: 5000,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      &quot;instanceHeartBeatTimeOut&quot;: 15000,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      &quot;ipDeleteTimeout&quot;: 30000,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      &quot;instanceIdGenerator&quot;: &quot;simple&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ],</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  &quot;lastRefTime&quot;: 1643191399694,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  &quot;checksum&quot;: &quot;&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  &quot;allIPs&quot;: false,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  &quot;reachProtectionThreshold&quot;: false,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  &quot;valid&quot;: true</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="步骤二新增-nacos-路由">步骤二：新增 Nacos 路由<a href="#步骤二新增-nacos-路由" class="hash-link" aria-label="步骤二：新增 Nacos 路由的直接链接" title="步骤二：新增 Nacos 路由的直接链接">​</a></h2><p>使用 Apache APISIX 提供的 Admin API 创建一个新的<a href="https://apisix.apache.org/zh/docs/apisix/admin-api#route" target="_blank" rel="noopener noreferrer">路由（Route）</a>，APISIX 通过 <code>upstream.discovery_type</code> 字段选择使用的服务发现类型，<code>upstream.service_name</code> 需要与注册中心的对应服务名进行关联，因此创建路由时指定服务发现类型为 <code>nacos</code> 。</p><div class="language-Shell codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-Shell codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">curl http://127.0.0.1:9080/apisix/admin/routes/1 -H &#x27;X-API-KEY: edd1c9f034335f136f87ad84b625c8f1&#x27; -X PUT -i -d &#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &quot;uri&quot;: &quot;/nacos/*&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &quot;upstream&quot;: {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        &quot;service_name&quot;: &quot;APISIX-NACOS&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        &quot;type&quot;: &quot;roundrobin&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        &quot;discovery_type&quot;: &quot;nacos&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}&#x27;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在上述命令中，请求头 <code>X-API-KEY</code> 是 Admin API 的访问 token，可以在 <code>conf/config.yaml</code> 文件中的 <code>apisix.admin_key.key</code> 查看。</p><p>添加成功后，正确返回结果示例如下：</p><div class="language-JSON codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-JSON codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  &quot;action&quot;: &quot;set&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  &quot;node&quot;: {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &quot;key&quot;: &quot;\/apisix\/routes\/1&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &quot;value&quot;: {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      &quot;update_time&quot;: 1643191044,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      &quot;create_time&quot;: 1643176603,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      &quot;priority&quot;: 0,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      &quot;uri&quot;: &quot;\/nacos\/*&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      &quot;upstream&quot;: {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        &quot;hash_on&quot;: &quot;vars&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        &quot;discovery_type&quot;: &quot;nacos&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        &quot;scheme&quot;: &quot;http&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        &quot;pass_host&quot;: &quot;pass&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        &quot;type&quot;: &quot;roundrobin&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        &quot;service_name&quot;: &quot;APISIX-NACOS&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      &quot;id&quot;: &quot;1&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      &quot;status&quot;: 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>除此之外，您还可以在 <code>upstream.discovery_args</code> 中传递其他服务相关参数用于指定服务所在的命名空间或组别，具体内容可参考下表：</p><table><thead><tr><th><strong>名字</strong></th><th><strong>类型</strong></th><th><strong>可选项</strong></th><th><strong>默认值</strong></th><th><strong>有效值</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>namespace_id</td><td>string</td><td>可选</td><td>public</td><td></td><td>服务所在的命名空间</td></tr><tr><td>group_name</td><td>string</td><td>可选</td><td>DEFAULT_GROUP</td><td></td><td>服务所在的组</td></tr></tbody></table><h2 class="anchor anchorWithStickyNavbar_LWe7" id="步骤三验证配置结果">步骤三：验证配置结果<a href="#步骤三验证配置结果" class="hash-link" aria-label="步骤三：验证配置结果的直接链接" title="步骤三：验证配置结果的直接链接">​</a></h2><p>使用以下命令发送请求至需要配置的路由。</p><div class="language-Shell codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-Shell codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">curl -i http://127.0.0.1:9080/nacos/</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>正常返回结果示例如下：</p><div class="language-Apache codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-Apache codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">HTTP/1.1 200 OK</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Content-Type: text/plain; charset=utf-8</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Content-Length: 11</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Connection: keep-alive</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Date: Thu, 27 Jan 2022 00:48:26 GMT</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Server: APISIX/2.12.0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Hello World</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>通过示例看到，Apache APISIX 中新增的路由已经可以通过 Nacos 服务发现找到正确的服务地址，并正常响应。</p><h1>总结</h1><p>本文为大家介绍了注册中心的概念以及 Apache APISIX 如何配合 Nacos 实现基于服务发现的路由代理。实际场景中如何进行 Apache APISIX 与 Nacos 的配合使用，您需要看具体的业务需求和过往技术架构。关于 <code>nacos</code> 插件的更多说明和完整配置信息，可参考官网文档：<a href="https://apisix.apache.org/zh/docs/apisix/discovery/nacos" target="_blank" rel="noopener noreferrer">nacos</a>。</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><meta itemprop="description" content="Nacos 计划发布v0.2版本，进一步融合Dubbo和SpringCloud生态"><meta itemprop="keywords" content="nacos,nacos0.2,alibaba,邢学超,Aliware Open Source,spring cloud"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/zh-cn/blog/chengdu-dubbo">Nacos 计划发布v0.2版本，进一步融合Dubbo和SpringCloud生态</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2023-10-10T11:47:41.000Z" itemprop="datePublished">2023年10月10日</time> · <!-- -->阅读需 7 分钟</div></header><div class="markdown" itemprop="articleBody"><p>在近期的Aliware Open Source 成都站的活动上，阿里巴巴高级工程师邢学超（于怀）分享了Nacos v0.2的规划和进度，并对Nacos v0.3的控制台进行了预览。Nacos v0.2将进一步融入Duboo和Spring Cloud生态，帮助开发者更好的在微服务场景下使用服务发现和动态配置管理。</p><p><img loading="lazy" src="https://cdn.nlark.com/lark/0/2018/png/11189/1537795153259-cc2c60c2-d7cb-431a-8858-cbd71b1c89e9.png" alt="undefined" class="img_ev3q"> </p><p>嘉宾介绍：邢学超（于怀），Nacos开源项目主要推动者，负责阿里巴巴内部 configserver、skywalker和taokeeper产品的架构和研发，爱好代码、篮球、吉他和摇滚，还记得超哥给盲人小朋友写的那首超温暖的歌么？<a href="https://mp.weixin.qq.com/s?__biz=MzU4NzU0MDIzOQ==&amp;mid=2247484141&amp;idx=2&amp;sn=30943616cf3d86393e906f82a3282bda&amp;chksm=fdeb308dca9cb99b6ca0e04112d2f5994a2a9cbdb5f43e5c38ef0c592001ab78e1d0be390120&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">传送门：给你们的歌</a></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="1nacos开源介绍">1. Nacos开源介绍<a href="#1nacos开源介绍" class="hash-link" aria-label="1. Nacos开源介绍的直接链接" title="1. Nacos开源介绍的直接链接">​</a></h2><p>Nacos是一个更易于帮助构建云原生应用的动态服务发现、配置和服务管理平台，脱胎于承载整个阿里巴巴集团的软负载产品，并于今年7月对外开源。开源以来，获得了来自社区的积极反馈，star数突破 1k 。</p><p>Nacos旨在将阿里巴巴在建设共享服务体系中使用的服务发现、配置及服务管理平台贡献给开源社区，通过打造Dubbo + Nacos的经典组合进一步释放Dubbo在云原生及Service Mesh时代中，在大规模微服务治理、流量治理、服务集成与服务共享等服务平台能力建设上的威力，同时Nacos关注对主流开源社区，如Spring Cloud和Kubernetes云原生体系的无缝对接与支持。该项目预计在7月中旬开放首个测试预览版本，并计划在0.8版本上，达到生产可用的状态。此外，Nacos支持注册中心和配置中心的分离部署，也关注上云的saas化部署，实现云下到云上的平滑迁移。</p><p>Github项目主页：
<a href="https://github.com/alibaba/nacos" target="_blank" rel="noopener noreferrer">https://github.com/alibaba/nacos</a>
Nacos官网：
<a href="http://nacos.io/" target="_blank" rel="noopener noreferrer">http://nacos.io/</a> </p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="2-nacos-v02进度和规划">2. Nacos v0.2进度和规划<a href="#2-nacos-v02进度和规划" class="hash-link" aria-label="2. Nacos v0.2进度和规划的直接链接" title="2. Nacos v0.2进度和规划的直接链接">​</a></h2><p>Nacos + Dubbo， 双中心重构，释放威力
Dubbo2.7将对注册中心和配置中心进行重构。注册中心将只用于Endpoint的同步，进一步减轻注册中心的存储压力，提高地址同步效率，同时缓解当前由于URL冗余在大规模推送时造成的Consumer端内存计算压力。配置中心将解决当前配置和地址信息耦合的问题，通过抽象动态配置层，让开发者可以对接微服务场景下更常用的、更专业的配置中心。这使得Nacos和Dubbo的完美融合成为可能，进一步释放Dubbo在服务治理、流量治理、服务运营和管理等方面的威力。</p><p>Nacos + Spring Cloud，多层融入，无缝贴合
Nacos在技术社区已经启动Nacos + Spring Cloud的工程，可无缝支持Spring Cloud，为Spring Cloud用户提供更简便的配置中心和注册中心的解决方案，使用Nacos不用再仅仅为服务和配置就需要在生产上hold住 Eureka，Spring Cloud Config Server，Git，Consul 起码四个开源产品。</p><p>Nacos v0.2，全方位注解，实现平滑迁移
在 Java 生态系统中，以 Spring Boot 和 Spring Cloud 为代表的微服务框架，引入了全新的编程模型，包括：
o	注解驱动（Annotation-Driven）
o	外部化配置（External Configuration）
o	自动装配（Auto-Configure）</p><p>Nacos将在v0.2支持原生Spring、Spring Boot、Spring Cloud中关于服务发现、配置管理的原生配置，适配Spring Boot、Spring Cloud标准，此外Nacos还是支持以下注解。
<img loading="lazy" src="https://cdn.nlark.com/lark/0/2018/png/11189/1537795187129-bf48b9b1-3560-4081-99fc-b9c99497525b.png" alt="undefined" class="img_ev3q"> </p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="3-nacos-代码演示--v03控制台预览">3. Nacos 代码演示 &amp; v0.3控制台预览<a href="#3-nacos-代码演示--v03控制台预览" class="hash-link" aria-label="3. Nacos 代码演示 &amp; v0.3控制台预览的直接链接" title="3. Nacos 代码演示 &amp; v0.3控制台预览的直接链接">​</a></h2><p>在分享中，于怀现场演示了如何快速运行一个Nacos应用、调用Nacos API、如何使用注解来运行Nacos。</p><p>同时，Nacos v0.3加入了控制台的功能，控制台分为两个内容，并会融合在一起：</p><ol><li>服务发现模块，包括服务上下线管理、服务权重、服务打标、服务健康信息和服务元信息的展现;</li><li>配置模块，提供配置列表、监听查询、推送轨迹等功能。</li></ol><p><img loading="lazy" src="https://cdn.nlark.com/lark/0/2018/png/11189/1537795211701-dc18d18c-99a6-40e0-824f-6519d8f8b434.png" alt="undefined" class="img_ev3q"> </p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="4-nacos-社区介绍和招募计划">4. Nacos 社区介绍和招募计划<a href="#4-nacos-社区介绍和招募计划" class="hash-link" aria-label="4. Nacos 社区介绍和招募计划的直接链接" title="4. Nacos 社区介绍和招募计划的直接链接">​</a></h2><p>Nacos强调社区化的发展与社区的多样性，采取PMC和Committer机制来管理社区，鼓励热情、注重细节、积极参与社区活动、对项目感兴趣的开发者参与到开源项目中来，希望在第一年就吸收至少超过5名来自其它公司的PMC，至少10名的外部Committer，依托于社区将产品做得更好，并计划在19年年初和CNCF基金会或apache基金会沟通捐赠适宜，社区贡献者会随之进入基金会体系。</p><p>画外音：我们准备了40个Nacos限量版纪念品，用于奖励参与“Nacos有奖活动”的开发者。
活动链接：
<a href="https://nacos.io/zh-cn/docs/activity.html" target="_blank" rel="noopener noreferrer">https://nacos.io/zh-cn/docs/activity.html</a></p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><meta itemprop="description" content="CMDB在企业中，一般用于存放与机器设备、应用、服务等相关的元数据。一般当企业的机器及应用达到一定规模后就需要这样一个系统来存储和管理它们的元数据。有一些广泛使用的属性例如机器的IP、主机名、机房、应用、region等，这些数据一般会在机器部署时录入到CMDB，运维或者监控平台会使用这些数据进行展示或者相关的运维操作。"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/zh-cn/blog/cmdb">Nacos打通CMDB实现就近访问</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2023-10-10T11:47:41.000Z" itemprop="datePublished">2023年10月10日</time> · <!-- -->阅读需 14 分钟</div></header><div class="markdown" itemprop="articleBody"><p>CMDB在企业中，一般用于存放与机器设备、应用、服务等相关的元数据。一般当企业的机器及应用达到一定规模后就需要这样一个系统来存储和管理它们的元数据。有一些广泛使用的属性例如机器的IP、主机名、机房、应用、region等，这些数据一般会在机器部署时录入到CMDB，运维或者监控平台会使用这些数据进行展示或者相关的运维操作。</p><p>在服务进行多机房或者多地域部署时，跨地域的服务访问往往延迟较高，一个城市内的机房间的典型网络延迟在1ms左右，而跨城市的网络延迟，例如上海到北京大概为30ms。此时自然而然的一个想法就是能不能让服务消费者和服务提供者进行同地域访问。阿里巴巴集团内部很早就意识到了这样的需求，在内部的实践中，这样的需求是通过和CMDB打通来实现的。在服务发现组件中，对接CMDB，然后通过配置的访问规则，来实现服务消费者到服务提供者的同地域优先，这样的调用每天都在阿里巴巴集团内部大量执行。</p><p><img loading="lazy" src="https://cdn.nlark.com/lark/0/2018/png/15356/1544702277705-0bbfca60-6629-477c-92bb-1a690e68f9cd.png#align=left&amp;display=inline&amp;height=330&amp;originHeight=330&amp;originWidth=448&amp;status=done&amp;width=448" class="img_ev3q"><br>图1 服务的同地域优先访问</p><p>这实际上就是一种负载均衡策略，在Nacos的规划中，丰富的服务端的可配置负载均衡策略是我们的重要发展方向，这与当前已有的注册中心产品不太一样。在设计如何在开源的场景中，支持就近访问的时候，与企业自带的CMDB集成是我们考虑的一个核心问题。除此之外，我们也在考虑将Nacos自身扩展为一个实现基础功能的CMDB。无论如何，我们都需要能够从某个地方获取IP的环境信息，这些信息要么是从企业的CMDB中查询而来，要么是从自己内置的存储中查询而来。</p><a name="pwyxgn"></a>## [](https://yuque.alibaba-inc.com/nacos/opensource/uk8inc/edit#pwyxgn)CMDB插件机制<p>先不考虑如何将CMDB的数据应用于负载均衡，我们需要首先在Nacos里将CMDB的数据通过某种方法获取。在实际使用中，基本上每个公司都会通过购买或者自研搭建自己的CMDB，那么为了能够解耦各个企业的CMDB具体实现，一个比较好的策略是使用SPI机制，约定CMDB的抽象调用接口，由各个企业添加自己的CMDB插件，无需任何代码上的重新构建，即可在运行状态下对接上企业的CMDB。</p><p><img loading="lazy" src="https://cdn.nlark.com/lark/0/2018/png/15356/1544842539697-cca20e3d-0f78-45b8-92b9-3b7559e838b2.png#align=left&amp;display=inline&amp;height=394&amp;originHeight=394&amp;originWidth=295&amp;status=done&amp;width=295" class="img_ev3q"><br>图2 Nacos CMDB SPI机制原理</p><p>如图2所示，Nacos定义了一个SPI接口，里面包含了与第三方CMDB约定的一些方法。用户依照约定实现了相应的SPI接口后，将实现打成jar包放置到Nacos安装目录下，重启Nacos即可让Nacos与CMDB的数据打通。整个流程并不复杂，但是理解CMDB SPI接口里方法和相应概念的含义不太简单。在这里对CMDB机制的相关概念和接口含义做一个详细说明。</p><a name="ga38al"></a><h2 class="anchor anchorWithStickyNavbar_LWe7" id="cmdb抽象概念"><a href="https://yuque.alibaba-inc.com/nacos/opensource/uk8inc/edit#ga38al" target="_blank" rel="noopener noreferrer"></a>CMDB抽象概念<a href="#cmdb抽象概念" class="hash-link" aria-label="cmdb抽象概念的直接链接" title="cmdb抽象概念的直接链接">​</a></h2><a name="d1gdtg"></a><h3 class="anchor anchorWithStickyNavbar_LWe7" id="实体entity"><a href="https://yuque.alibaba-inc.com/nacos/opensource/uk8inc/edit#d1gdtg" target="_blank" rel="noopener noreferrer"></a>实体（Entity）<a href="#实体entity" class="hash-link" aria-label="实体entity的直接链接" title="实体entity的直接链接">​</a></h3><p>实体是作为CMDB里数据的承载方，在一般的CMDB中，一个实体可以指一个IP、应用或者服务。而这个实体会有很多属性，例如IP的机房信息，服务的版本信息等。</p><a name="hig8ag"></a><h3 class="anchor anchorWithStickyNavbar_LWe7" id="实体类型entity-type"><a href="https://yuque.alibaba-inc.com/nacos/opensource/uk8inc/edit#hig8ag" target="_blank" rel="noopener noreferrer"></a>实体类型（Entity Type）<a href="#实体类型entity-type" class="hash-link" aria-label="实体类型entity-type的直接链接" title="实体类型entity-type的直接链接">​</a></h3><p>我们并不限定实体一定是IP、应用或者服务，这取决于实际的业务场景。Nacos有计划在未来支持不同的实体类型，不过就目前来说，服务发现需要的实体类型是IP。</p><a name="bm37ew"></a><h3 class="anchor anchorWithStickyNavbar_LWe7" id="标签label"><a href="https://yuque.alibaba-inc.com/nacos/opensource/uk8inc/edit#bm37ew" target="_blank" rel="noopener noreferrer"></a>标签（Label）<a href="#标签label" class="hash-link" aria-label="标签label的直接链接" title="标签label的直接链接">​</a></h3><p>Label是我们抽象出的Entity属性，Label定义为一个描述Entity属性的K-V键值对。Label的key和value的取值范围一般都是预先定义好的，当需要对Label进行变更，如增加新的key或者value时，需要调用单独的接口并触发相应的事件。一个常见的Label的例子是IP的机房信息，我们认为机房（site）是Label的key，而机房的集合（site1, site2, site3）是Label的value，这个Label的定义就是：site: {site1, site2, site3}。</p><a name="1osqbb"></a><h3 class="anchor anchorWithStickyNavbar_LWe7" id="实体事件entity-event"><a href="https://yuque.alibaba-inc.com/nacos/opensource/uk8inc/edit#1osqbb" target="_blank" rel="noopener noreferrer"></a>实体事件（Entity Event）<a href="#实体事件entity-event" class="hash-link" aria-label="实体事件entity-event的直接链接" title="实体事件entity-event的直接链接">​</a></h3><p>实体的标签的变更事件。当CMDB的实体属性发生变化，需要有一个事件机制来通知所有订阅方。为了保证实体事件携带的变更信息是最新准确的，这个事件里只会包含变更的实体的标识以及变更事件的类型，不会包含变更的标签的值。</p><a name="3vu8pv"></a><h2 class="anchor anchorWithStickyNavbar_LWe7" id="cmdb约定接口"><a href="https://yuque.alibaba-inc.com/nacos/opensource/uk8inc/edit#3vu8pv" target="_blank" rel="noopener noreferrer"></a>CMDB约定接口<a href="#cmdb约定接口" class="hash-link" aria-label="cmdb约定接口的直接链接" title="cmdb约定接口的直接链接">​</a></h2><p>在设计与CMDB交互接口的时候，我们参考了内部对CMDB的访问接口，并与若干个外部客户进行了讨论。我们最终确定了以下要求第三方CMDB插件必须实现的接口：</p><a name="hc8tsu"></a><h3 class="anchor anchorWithStickyNavbar_LWe7" id="获取标签列表"><a href="https://yuque.alibaba-inc.com/nacos/opensource/uk8inc/edit#hc8tsu" target="_blank" rel="noopener noreferrer"></a>获取标签列表<a href="#获取标签列表" class="hash-link" aria-label="获取标签列表的直接链接" title="获取标签列表的直接链接">​</a></h3><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Set&lt;String&gt; getLabelNames();</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这个方法将返回CMDB中需要被Nacos识别的标签名集合，CMDB插件可以按需决定返回什么标签个Nacos。不在这个集合的标签将会被Nacos忽略，即使这个标签出现在实体的属性里。我们允许这个集合会在运行时动态变化，Nacos会定时去调用这个接口刷新标签集合。</p><a name="2v2vks"></a><h3 class="anchor anchorWithStickyNavbar_LWe7" id="获取实体类型"><a href="https://yuque.alibaba-inc.com/nacos/opensource/uk8inc/edit#2v2vks" target="_blank" rel="noopener noreferrer"></a>获取实体类型<a href="#获取实体类型" class="hash-link" aria-label="获取实体类型的直接链接" title="获取实体类型的直接链接">​</a></h3><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Set&lt;String&gt; getEntityTypes();</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>获取CMDB里的实体的类型集合，不在这个集合的实体类型会被Nacos忽略。服务发现模块目前需要的实体类似是ip，如果想要通过打通CMDB数据来实现服务的高级负载均衡，请务必在返回集合里包含“ip”。</p><a name="sw9ryi"></a><h3 class="anchor anchorWithStickyNavbar_LWe7" id="获取标签详情"><a href="https://yuque.alibaba-inc.com/nacos/opensource/uk8inc/edit#sw9ryi" target="_blank" rel="noopener noreferrer"></a>获取标签详情<a href="#获取标签详情" class="hash-link" aria-label="获取标签详情的直接链接" title="获取标签详情的直接链接">​</a></h3><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Label getLabel(String labelName);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>获取标签的详细信息。返回的Label类里包含标签的名字和标签值的集合。如果某个实体的这个标签的值不在标签值集合里，将会被视为无效。</p><a name="va70wg"></a><h3 class="anchor anchorWithStickyNavbar_LWe7" id="查询实体的标签值"><a href="https://yuque.alibaba-inc.com/nacos/opensource/uk8inc/edit#va70wg" target="_blank" rel="noopener noreferrer"></a>查询实体的标签值<a href="#查询实体的标签值" class="hash-link" aria-label="查询实体的标签值的直接链接" title="查询实体的标签值的直接链接">​</a></h3><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">String getLabelValue(String entityName, String entityType, String labelName);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">String getLabelValues(String entityName, String entityType);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这里包含两个方法，一个是获取实体某一个标签名对应的值，一个是获取实体所有标签的键值对。参数里包含实体的值和实体的类型。注意，这个方法并不会在每次在Nacos内部触发查询时去调用，Nacos内部有一个CMDB数据的缓存，只有当这个缓存失效或者不存在时，才会去访问CMDB插件查询数据。为了让CMDB插件的实现尽量简单，我们在Nacos内部实现了相应的缓存和刷新逻辑。</p><a name="byohax"></a><h3 class="anchor anchorWithStickyNavbar_LWe7" id="查询实体"><a href="https://yuque.alibaba-inc.com/nacos/opensource/uk8inc/edit#byohax" target="_blank" rel="noopener noreferrer"></a>查询实体<a href="#查询实体" class="hash-link" aria-label="查询实体的直接链接" title="查询实体的直接链接">​</a></h3><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">String getAllEntities();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Entity getEntity(String entityName, String entityType);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>查询实体包含两个方法：查询所有实体和查询单个实体。查询单个实体目前其实就是查询这个实体的所有标签，不过我们将这个方法与获取所有标签的方法区分开来，因为查询单个实体方法后面可能会进行扩展，比查询所有标签获取的信息要更多。</p><p>查询所有实体则是一次性将CMDB的所有数据拉取过来，该方法可能会比较消耗性能，无论是对于Nacos还是CMDB。Nacos内部调用该方法的策略是通过可配置的定时任务周期来定时拉取所有数据，在实现该CMDB插件时，也请关注CMDB服务本身的性能，采取合适的策略。</p><a name="tgn5ut"></a><h3 class="anchor anchorWithStickyNavbar_LWe7" id="查询实体事件"><a href="https://yuque.alibaba-inc.com/nacos/opensource/uk8inc/edit#tgn5ut" target="_blank" rel="noopener noreferrer"></a>查询实体事件<a href="#查询实体事件" class="hash-link" aria-label="查询实体事件的直接链接" title="查询实体事件的直接链接">​</a></h3><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">List&lt;EntityEvent&gt; getEntityEvents(long timestamp);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这个方法意在获取最近一段时间内实体的变更消息，增量的去拉取变更的实体。因为Nacos不会实时去访问CMDB插件查询实体，需要这个拉取事件的方法来获取实体的更新。参数里的timestamp为上一次拉取事件的时间，CMDB插件可以选择使用或者忽略这个参数。</p><a name="p7g6dw"></a><h2 class="anchor anchorWithStickyNavbar_LWe7" id="cmdb插件开发流程"><a href="https://yuque.alibaba-inc.com/nacos/opensource/uk8inc/edit#p7g6dw" target="_blank" rel="noopener noreferrer"></a>CMDB插件开发流程<a href="#cmdb插件开发流程" class="hash-link" aria-label="cmdb插件开发流程的直接链接" title="cmdb插件开发流程的直接链接">​</a></h2><p>参考 <a href="https://github.com/nacos-group/nacos-examples" target="_blank" rel="noopener noreferrer">https://github.com/nacos-group/nacos-examples</a>，这里已经给出了一个示例plugin实现。<br>具体步骤如下：</p><ol><li>新建一个maven工程，引入依赖nacos-api:</li></ol><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">&lt;dependency&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &lt;groupId&gt;com.alibaba.nacos&lt;/groupId&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &lt;artifactId&gt;nacos-api&lt;/artifactId&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &lt;version&gt;0.7.0&lt;/version&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        &lt;/dependency&gt;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol start="2"><li>引入打包插件：</li></ol><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">&lt;plugin&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                &lt;configuration&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    &lt;descriptorRefs&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    &lt;/descriptorRefs&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                &lt;/configuration&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &lt;/plugin&gt;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol start="3"><li>定义实现类，继承com.alibaba.nacos.api.cmdb.CmdbService，并实现相关方法。<br><img loading="lazy" src="https://cdn.nlark.com/lark/0/2018/png/15356/1543916500193-213df77a-096d-4fd9-a283-85241a856fbf.png#align=left&amp;display=inline&amp;height=116&amp;originHeight=116&amp;originWidth=585&amp;status=done&amp;width=585" class="img_ev3q"><br></li><li>在src/main/resource/目录下新建目录：META-INF/services<br><img loading="lazy" src="https://cdn.nlark.com/lark/0/2018/png/15356/1543916595978-fd322205-16c1-4a95-9cdc-4a6292ee3b66.png#align=left&amp;display=inline&amp;height=96&amp;originHeight=96&amp;originWidth=379&amp;status=done&amp;width=379" class="img_ev3q"><br></li><li>在src/main/resources/META-INF/services目录下新建文件com.alibaba.nacos.api.cmdb.CmdbService，并在文件里将第三步中创建的实现类全名写入该文件:<br><img loading="lazy" src="https://cdn.nlark.com/lark/0/2018/png/15356/1545036650034-75d11aee-8738-485f-9426-52e560b059cd.png#align=left&amp;display=inline&amp;height=136&amp;originHeight=178&amp;originWidth=944&amp;status=done&amp;width=719" class="img_ev3q"><br></li><li>代码自测完成后，执行命令进行打包：</li></ol><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">mvn package assembly:single -Dmaven.test.skip=true</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol start="7"><li>将target目录下的包含依赖的jar包上传到nacos CMDB插件目录：</li></ol><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">{nacos.home}/plugins/cmdb</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol start="8"><li>在nacos的application.properties里打开加载插件开关：</li></ol><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">nacos.cmdb.loadDataAtStart=true</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol start="9"><li>重启nacos Server，即可加载到您实现的nacos-cmdb插件获取您的CMDB数据。<br></li></ol><a name="5mpctx"></a><h2 class="anchor anchorWithStickyNavbar_LWe7" id="使用selector实现同机房优先访问"><a href="https://yuque.alibaba-inc.com/nacos/opensource/uk8inc/edit#5mpctx" target="_blank" rel="noopener noreferrer"></a>使用Selector实现同机房优先访问<a href="#使用selector实现同机房优先访问" class="hash-link" aria-label="使用selector实现同机房优先访问的直接链接" title="使用selector实现同机房优先访问的直接链接">​</a></h2><p>在拿到CMDB的数据之后，就可以运用CMDB数据的强大威力来实现多种灵活的负载均衡策略了，下面举例来说明如何使用CMDB数据和Selector来实现就近访问。</p><p>假设目前Nacos已经通过CMDB拿到了一些IP的机房信息，且它们对应的标签信息如下：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">11.11.11.11</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    site: x11</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22.22.22.22</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    site: x12</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">33.33.33.33</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    site: x11</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">44.44.44.44</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    site: x12</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">55.55.55.55</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    site: x13</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>11.11.11.11、22.22.22.22、33.33.33.33、44.44.44.44和55.55.55.55.55都包含了标签site，且它们对应的值分别为x11、x12、x11、x12、x13。我们先注册一个服务，下面挂载IP11.11.11.11和22.22.22.22。<br><img loading="lazy" src="https://cdn.nlark.com/lark/0/2018/png/15356/1545035855381-5d9dcfad-75ab-43ad-a084-8ae4a65f914c.png#align=left&amp;display=inline&amp;height=307&amp;originHeight=516&amp;originWidth=1254&amp;status=done&amp;width=747" class="img_ev3q"><br>图3 服务详情</p><p>然后我们修改服务的“服务路由类型”，并配置为基于同site优先的服务路由：<br><img loading="lazy" src="https://cdn.nlark.com/lark/0/2018/png/15356/1545035973200-497c0649-b652-4c36-bf6c-7cddfc5b75c6.png#align=left&amp;display=inline&amp;height=499&amp;originHeight=499&amp;originWidth=610&amp;status=done&amp;width=610" class="img_ev3q"><br>图4 编辑服务路由类型</p><p>这里我们将服务路由类型选择为标签，然后输入标签的表达式：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">CONSUMER.label.site = PROVIDER.label.site</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这个表达式的格式和我们抽象的Selector机制有关，具体将会在另外一篇文章中介绍。在这里您需要记住的就是，任何一个如下格式的表达式：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">CONSUMER.label.labelName = PROVIDER.label.labelName</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>将能够实现基于同labelName优先的负载均衡策略。</p><p>然后假设服务消费者的IP分别为33.33.33.33、44.44.44.44和55.55.55.55，它们在使用如下接口查询服务实例列表：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">naming.selectInstances(&quot;nacos.test.1&quot;, true)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>那么不同的消费者，将获取到不同的实例列表。33.33.33.33获取到11.11.11.11，44.44.44.44将获取到22.22.22.22，而55.55.55.55将同时获取到11.11.11.11和22.22.22.22。</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><meta itemprop="description" content="Nacos 进入CNCF landscape"><meta itemprop="keywords" content="nacos,cncf,alibaba,landscape"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/zh-cn/blog/cncf">Nacos 进入CNCF landscape</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2023-10-10T11:47:41.000Z" itemprop="datePublished">2023年10月10日</time> · <!-- -->阅读需 1 分钟</div></header><div class="markdown" itemprop="articleBody"><h2 class="anchor anchorWithStickyNavbar_LWe7" id="nacos-被cncf-纳入landscape大图">Nacos 被CNCF 纳入landscape大图。<a href="#nacos-被cncf-纳入landscape大图" class="hash-link" aria-label="Nacos 被CNCF 纳入landscape大图。的直接链接" title="Nacos 被CNCF 纳入landscape大图。的直接链接">​</a></h2><p><img loading="lazy" src="https://cdn.nlark.com/lark/0/2018/png/11189/1540738282849-61e2022a-46a9-4d81-ae16-6d6f0515450b.png" alt="image.png | left | 747x408" class="img_ev3q"></p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><meta itemprop="description" content="Consul与kubernetes整合公告[翻译]"><meta itemprop="keywords" content="Consul,kubernetes"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/zh-cn/blog/consul-k8s">Consul与kubernetes整合公告[翻译]</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2023-10-10T11:47:41.000Z" itemprop="datePublished">2023年10月10日</time> · <!-- -->阅读需 8 分钟</div></header><div class="markdown" itemprop="articleBody"><h2 class="anchor anchorWithStickyNavbar_LWe7" id="导读">导读<a href="#导读" class="hash-link" aria-label="导读的直接链接" title="导读的直接链接">​</a></h2><blockquote><p>Consul是目前业界比较火的服务发现与配置产品，它率先将服务发现和配置管理等分布式服务当中使用到的基础服务进行整合，对外提供分布式及高可用的服务。Consul目前有开源版本和商业化版本同时演进，这也是国内可以借鉴的一种开源策略。同时，Consul对于新技术趋势的跟进和整合，也是值得我们学习和参考的。</p><p>本文翻译了Consul对于Kubernetes的整合所发布的公告文章（<a href="https://www.hashicorp.com/blog/consul-plus-kubernetes" target="_blank" rel="noopener noreferrer">原文地址</a>）。Consul通过支持Service Mesh，并提供对Kubernetes的无缝支持，与目前最受社区热捧的产品进行绑定，并通过功能预告的形式，来达到对产品宣传效果的最大化。</p><p>与Consul产品对应的，阿里巴巴在近期开源了其服务发现与配置管理产品<a href="https://nacos.io" target="_blank" rel="noopener noreferrer">Nacos</a>。Nacos是阿里巴巴集团内部VIPServer、ConfigServer和Diamond三个支撑双十一的重要中间件产品整合而来。Nacos主要关注产品的极致易用以及与云原生的深度整合，主要支持服务发现、配置管理等功能。很快，Nacos也会与Service Mesh进行整合，同时在集团内部和开源进行发布，利用阿里巴巴丰富的场景和开源社区的力量，将Nacos打造成云原生生态中不可或缺的基础产品。</p></blockquote><p>我们很高兴地宣布HashiCorp Consul与Kubernetes深度整合的多项功能。 这篇文章将分享将在未来几周内发布的一系列初步功能。</p><p>这些功能包括用于在Kubernetes上安装Consul的官方Helm Chart，与Consul自动同步Kubernetes服务（反之亦然），外部Consul Agent自动加入Kubernetes中的集群，用于Connect自动保护pod的注入器，以及对Envoy的支持。</p><p>除了与Kubernetes本地集成之外，这些功能还有助于解决多个Kubernetes集群之间以及Kubernetes服务与非Kubernetes服务交互多项重要跨集群挑战。 我们很高兴与您分享这项工作。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="功能点">功能点<a href="#功能点" class="hash-link" aria-label="功能点的直接链接" title="功能点的直接链接">​</a></h2><p>以下是将在未来几周内公布和发布的功能列表。后续公告博客将详细介绍每个项目，每个项目都将链接到该公告帖子。</p><ul><li><strong>Helm Chart</strong>。用于在Kubernetes上安装，配置和升级Consul的官方Helm Chart。此Helm Chart还将支持Kubernetes的其他功能的自动安装和配置，例如目录同步。</li><li><strong>Kubernetes自动加入</strong>。Consul的云自动加入功能将更新，以支持发现和加入基于Kubernetes的Agent代理。这将使外部Consul Agent加入在Kubernetes中运行的Consul集群。</li><li><strong>服务目录同步：从K8S到Consul</strong>。适当的Kubernetes服务将自动同步到Consul目录，使非Kubernetes服务能够发现并连接到Kubernetes中运行的服务。</li><li><strong>服务目录同步：从Consul到K8S</strong>。Consul服务将同步到Kubernetes服务，以便应用程序可以使用Kubernetes本地服务发现来发现和连接在Kubernetes之外运行的服务。</li><li><strong>Connect自动注入</strong>。部署在Kubernetes中的Pod可以配置为自动使用Connect通过TLS进行安全通信。</li><li>支持<strong>Envoy Proxy</strong>。配置为使用Connect自动注入的Pod可以使用Envoy Proxy进行第4层通信，通过Connect进行保护。 Envoy也将用于非Kubernetes的Connect部署。</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="与kubernetes整合">与Kubernetes整合<a href="#与kubernetes整合" class="hash-link" aria-label="与Kubernetes整合的直接链接" title="与Kubernetes整合的直接链接">​</a></h2><p>我们目前正在与Kubernetes在多个产品上进行密切整合。通过使我们的产品更易于运行以及集成和增强Kubernetes功能，我们看到了解决纯Kubernetes用户挑战的机会。</p><p>这种集成的核心原则是增强现有功能而不是替换。服务、ConfigMaps及Secrets等功能是Kubernetes核心工作流程的一部分。更高级别的工具和扩展利用这些核心原语。因此，我们也在整合和增强这些核心原语。例如，Consul目录同步将Consul目录中的外部服务转换为一级的Kubernetes服务资源。然后，在Kubernetes中运行的应用程序可以发现并连接到非Kubernetes服务。</p><p>除了使我们的产品在Kubernetes中更易用和更自然之外，这些集成还允许用户在与非Kubernetes工作负载共享的环境中更好地工作。 虽然新用户很容易在纯Kubernetes环境中启动，但大多数部署必须与在云计算环境中运行的外部服务，本地数据中心等进行交互。 像Consul这样的HashiCorp产品专为这些异构环境而设计。 通过实现更自然的Kubernetes体验，非Kubernetes应用程序与Kubernetes应用程序交互变得同样自然。</p><h1>下一步</h1><p>我们很高兴地宣布第一批HashiCorp Consul和Kubernetes的功能。 这些功能使得在Kubernetes上运行Consul，与非Kubernetes服务进行交互，在Kubernetes内外进行安全通信等等更加容易。 这些功能中的每一项都将在未来几周内全面公布和发布，从下周的Helm Chart开始。</p><p>Terraform和Vault也与Kubernetes紧密集成。 Terraform Kubernetes提供商现在拥有一名专职工程师，并且在未来几个月内应该会迅速改进。 Vault正在开发新的集成，也将很快公布。</p><p>如果您对Kubernetes，我们的工具以及改进这些集成感兴趣，请加入我们！ 我们有一些针对Kubernetes集成的生态系统工程师岗位需求。</p></div></article><nav class="pagination-nav" aria-label="博文列表分页导航"><a class="pagination-nav__link pagination-nav__link--prev" href="/zh-cn/blog"><div class="pagination-nav__label">较新的博文</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/zh-cn/blog/page/3"><div class="pagination-nav__label">较旧的博文</div></a></nav></main></div></div></div></div>
<script src="/zh-cn/assets/js/runtime~main.799a6c4f.js"></script>
<script src="/zh-cn/assets/js/main.99abaf7c.js"></script>
</body>
</html>